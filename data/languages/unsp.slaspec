# Sleigh specification for u'nSP

define endian=little;
define alignment=2;


# 22 bit address space -> size=3
# Each address accesses 16 bits (2x8) -> wordsize=2
define space ram type=ram_space size=3 wordsize=2 default;
define space register type=register_space size=2;

# General purpose Registers
# bp is sometimes called r5
define register offset=0 size=2     [ sp r1 r2 r3 r4 bp ];

# Status register
# We'll only update sr when it's accessed
define register offset=0xc size=2    [ sr ];

# Status register components
# Store these discretely, modelling after the ARM SLEIGH spec
define register offset=0x10 size=1   [ C_flag S_flag Z_flag N_flag ds ];

# Program counter
# In reality, there is no pc_full, only pc and cs, which is the upper 6 bits of the address
# The call instruction is cross-bank, as are goto's
# And the program counter will naturally cross banks i.e. 0x4ffff + 1 -> 0x50000
# In order for calls and gotos to work correctly, we use this fake register. Unfortunately,
# this makes contents of cs incorrect.
# Until Sleigh adds composite registers (or we find a better solution) this will remain.
# ---
# Use pc_full as actual program counter, and pc for pushing to stack
# Separate them from sr so Ghidra advancing instruction pointer does not affect
# value of other things
# TODO this comment is now misleading due to the new implementation, revise
define register offset=0x15 size=3    [ pc_full ];
define register offset=0x15 size=2    [ pc ];
define register offset=0x17 size=1    [ cs ];

# Flag register (since u'nSP 1.2)
define register offset=0x20 size=2    [ fr ];

# Flag register components
define register offset=0x30 size=1    [ irqnest irq fiq fir_mov fraction sec_bank aq ];
define register offset=0x37 size=1    [ pri sb ];

# Second bank (since u'nSP 1.2)
define register offset=0x40 size=2  [ sr1 sr2 sr3 sr4 ];
# TODO: hook them up

# u'nSP 1.3-specific registers
# TODO: hook them up
define register offset=0x22 size=2  [ ss_full mds ];
# SS register is only 6 bits, but chances are the storage is 16 bits
@define ss "ss_full[0,6]"

# Extended registers (u'nSP 2.0)
define register offset=0x50 size=2 [ r8 r9 r10 r11 r12 r13 r14 r15 ];

# Context for extended instructions
# See https://github.com/NationalSecurityAgency/ghidra/issues/2365
#define context contextreg
#    isExtended=(0,0) # 0:initial, 1:instruction-parse
#;

define token instr(16)
    opFull=(0, 15)
    op0=(12, 15)
    opA_r=(9, 11)
    opA_nosr=(9, 11)
    opA_v=(9, 11)
    opA_p=(9, 11)
    opA_p2=(9, 11)
    opA_p3=(9, 11)
    opA_p4=(9, 11)
    opA_p5=(9, 11)
    opA_p6=(9, 11)
    opA_p7=(9, 11)

        opA_9=(9, 9)
        opA_10=(10, 10)
    
    opA_u1=(9, 11)
    opA_u2=(9, 11)
    opA_u3=(9, 11)
    opA_u4=(9, 11)
    opA_u5=(9, 11)
    opA_u6=(9, 11)

    op1=(6, 8)
    opN=(3, 5)
        opFlag=(5, 5)
        opShift=(3, 4)
    opB_r=(0, 2)
    opB_nosr=(0, 2)
    opB_v=(0, 2)
    opimm=(0, 5)

    opMulSize=(3,6)

    opE1=(7, 8)
    opE2=(4, 6)

    opBitFn=(4, 5)
    opBitFlg=(3, 3)
    opBitN=(0, 3)
;

attach variables [ opA_r opB_r ] [ sp r1 r2 r3 r4 bp sr pc ];
attach variables [ opA_nosr opB_nosr ] [ sp r1 r2 r3 r4 bp _ pc ];
# Bizarrely shifted
attach variables [ opA_p ] [ r1 r2 r3 r4 bp sr pc _ ];
attach variables [ opA_p2 ] [ r2 r3 r4 bp sr pc _ _ ];
attach variables [ opA_p3 ] [ r3 r4 bp sr pc _ _ _ ];
attach variables [ opA_p4 ] [ r4 bp sr pc _ _ _ _ ];
attach variables [ opA_p5 ] [ bp sr pc _ _ _ _ _ ];
attach variables [ opA_p6 ] [ sr pc _ _ _ _ _ _ ];
attach variables [ opA_p7 ] [ pc _ _ _ _ _ _ _ ];

attach variables [ opA_u1 ] [ _ sp r1 r2 r3 r4 bp sr ];
attach variables [ opA_u2 ] [ _ _ sp r1 r2 r3 r4 bp ];
attach variables [ opA_u3 ] [ _ _ _ sp r1 r2 r3 r4 ];
attach variables [ opA_u4 ] [ _ _ _ _ sp r1 r2 r3 ];
attach variables [ opA_u5 ] [ _ _ _ _ _ sp r1 r2 ];
attach variables [ opA_u6 ] [ _ _ _ _ _ _ sp r1 ];

define token immtoken(16)
    imm16=(0,15);

define pcodeop segment;    # Define special pcodeop that calculates the RAM address
                           # given the segment selector and offset as input
define pcodeop exp;
define pcodeop muls;

# Tables for level of indirection so SR can be packed and unpacked
UnpackSR: is epsilon {
    local tmp_ds = (sr >> 10) & 0x3f;
    local tmp_cs = sr & 0x3f;

    ds = tmp_ds:1;
    # Done same way as in ARM `msr cpsr,rm`
    N_flag = ((sr >> 9) & 0x1) != 0;
    Z_flag = ((sr >> 8) & 0x1) != 0;
    S_flag = ((sr >> 7) & 0x1) != 0;
    C_flag = ((sr >> 6) & 0x1) != 0;
    cs = tmp_cs:1;
}

PackSR: is epsilon {
    sr = 
        (zext(ds) << 10) |
        (zext(N_flag) << 9) |
        (zext(Z_flag) << 8) |
        (zext(S_flag) << 7) |
        (zext(C_flag) << 6) |
        zext(cs[0,6]);
    export sr;
}

UnpackSR_opA: is opA_v=6 & UnpackSR { }
UnpackSR_opA: is opA_v!=6 { }

opA: opA_r is opA_r { export opA_r; }

opARead: sr is sr & opA_v=6 & PackSR { export PackSR; }
opARead: opA is opA { export opA; }

opB: sr is sr & opB_v=6 & PackSR { export PackSR; }
opB: opB_r is opB_r { export opB_r; }

# Macros

macro push(x) {
    local data:2 = x;
    local stack_addr:3 = segment(0:1, sp);
    *:2 stack_addr = data;
    sp = sp - 1;
}

macro setResultFlags(reg) {
    Z_flag = (reg == 0);
    N_flag = (reg s< 0);
}

# Following adapted from x86 processor
# Must be called after setResultFlags() due to dependence on N_flag

# I have no idea how the sign flag is actually supposed to be calculated,
# but according to the u'nSP programmer's guide overflow occurs when N and S
# are different, so let's set per overflow

macro setAddFlags(op1,op2) {
    local of = scarry(op1, op2);
    C_flag = carry(op1, op2);
    S_flag = of ^^ N_flag;
}

macro setAddCarryFlags(op1,op2) {
	local CFcopy = zext(C_flag);
	local cf = carry(op1, op2);
    local of = scarry(op1, op2);
    local result = op1 + op2;
	cf = cf || carry(result, CFcopy);
    of = of ^^ scarry(result, CFcopy);
    C_flag = cf;
	S_flag = of ^^ N_flag;
}

macro setSubtractFlags(op1,op2) {
    local of = sborrow(op1, op2);
    C_flag = carry(op1, ~op2);
	S_flag = of ^^ N_flag;
}

macro setSubtractCarryFlags(op1,op2) {
	local CFcopy = C_flag;
    # For carry, use original `a + ~b + C`
    # For borrow, use `a - b - !C`
	local cf = carry(op1, ~op2);
    local of = sborrow(op1, op2);
    # Operation before carry is `op1 + ~op2`
	local result = op1 - op2;
    # a - b == a + ~b + 1, need to remove the 1
	cf = cf || carry(result - 1, zext(CFcopy));
    of = of ^^ sborrow(result, zext(!CFcopy));
    C_flag = cf;
	S_flag = of ^^ N_flag;
}

# Instructions

# Jumps
# Local to a bank, will wrap around (unlike call/goto)

# Positive jump with 6bit immediate
RelP6:   relAddr is opimm [ relAddr=(inst_start & 0x3f0000) + ((inst_next+opimm) & 0xffff); ] { export *:3 relAddr; }
# Negative jump with 6bit immediate
RelN6:   relAddr is opimm [ relAddr=(inst_start & 0x3f0000) + ((inst_next-opimm) & 0xffff); ] { export *:3 relAddr; }

# Conditions
cc: "b"  is op0=0x0     { local tmp = !C_flag; export tmp; }
cc: "ae" is op0=0x1     { export C_flag; }
cc: "ge" is op0=0x2     { local tmp = !S_flag; export tmp; }
cc: "l"  is op0=0x3     { export S_flag; }
cc: "ne" is op0=0x4     { local tmp = !Z_flag; export tmp; }
cc: "e"  is op0=0x5     { export Z_flag; }
cc: "pl" is op0=0x6     { local tmp = !N_flag; export tmp; }
cc: "mi" is op0=0x7     { export N_flag; }
cc: "be" is op0=0x8     { local tmp = Z_flag || !C_flag; export tmp; }
cc: "a"  is op0=0x9     { local tmp = !Z_flag && C_flag; export tmp; }
cc: "le" is op0=0xa     { local tmp = Z_flag || S_flag; export tmp; }
cc: "g"  is op0=0xb     { local tmp = !Z_flag && !S_flag; export tmp; }
cc: "vc" is op0=0xc     { local tmp = N_flag == S_flag; export tmp; }
cc: "vs" is op0=0xd     { local tmp = N_flag != S_flag; export tmp; }

:j^cc RelP6 is opA_v=7 & cc & op1=0 & RelP6 {
    if(cc) goto RelP6;
}
:j^cc RelN6 is opA_v=7 & cc & op1=1 & RelN6 {
    if(cc) goto RelN6;
}
:jmp RelP6 is opA_v=7 & op0=0xe & op1=0 & RelP6 {
    goto RelP6;
}
:jmp RelN6 is opA_v=7 & op0=0xe & op1=1 & RelN6 {
    goto RelN6;
}

# ALU6

IndirectOp: ""[opB] is opN=0 & opB {
    export *:2 opB;
} 
IndirectOp: ""[opB--] is opN=1 & opB {
    local tmp = opB;
    opB = opB - 1;
    export *:2 tmp;
} 
IndirectOp: ""[opB++] is opN=2 & opB {
    local tmp = opB;
    opB = opB + 1;
    export *:2 tmp;
} 
IndirectOp: ""[++opB] is opN=3 & opB {
    opB = opB + 1;
    export *:2 opB;
} 
IndirectOp: "ds":[opB] is opN=4 & opB {
    local addr:3 = segment(ds, opB);
    export *:2 addr;
} 
IndirectOp: "ds":[opB--] is opN=5 & opB {
    local addr:3 = segment(ds, opB);
    ds = ds - sborrow(opB, 1);
    opB = opB - 1;
    export *:2 addr;
} 
IndirectOp: "ds":[opB++] is opN=6 & opB {
    local addr:3 = segment(ds, opB);
    ds = ds + scarry(opB, 1);
    opB = opB + 1;
    export *:2 addr;
} 
IndirectOp: "ds":[++opB] is opN=7 & opB {
    ds = ds + scarry(opB, 1);
    opB = opB + 1;
    local addr:3 = segment(ds, opB);
    export *:2 addr;
}
# ALU with base+displacement
ALU6BaseDisplacement: ["bp"+opimm] is op1=0 & opimm {
    # Stack is always located in Bank 0
    local stack_addr:3 = segment(0:1, bp+opimm);
    local term = *:2 stack_addr;
    export term;
}
# ALU with 6bit immediate
ALU6Opimm: opimm is opimm { local tmp:2 = opimm; export tmp; }
ALU6Reg: opB is opB { local tmp:2 = opB; export tmp; } 
ALU6Mem: ""[opimm] is opimm { export *:2 opimm; }
ALU6RShift: opB "asr" shift is opShift & opB [ shift = opShift + 1; ] {
    # Save shifted out bits in sb
    local tmp = (opB:1 << 4) | sb;
    tmp = tmp >> shift;
    sb = tmp & 0xf:1;

    local val:2 = opB s>> shift; 
    export val;
}
ALU6LShift: opB "lsl" shift is opFlag=0 & opShift & opB [ shift = opShift + 1; ] {
    # Save shifted out bits in sb
    local tmp = (sb << 8) | opB(1);
    tmp = tmp >> (8 - shift);
    sb = tmp & 0xf:1;

    local val:2 = opB << shift;
    export val;
}
ALU6LShift: opB "lsr" shift is opFlag=1 & opShift & opB [ shift = opShift + 1; ] {
    # Save shifted out bits in sb
    local tmp = (opB:1 << 4) | sb;
    tmp = tmp >> shift;
    sb = tmp & 0xf:1;

    local val:2 = opB >> shift; 
    export val;
}
ALU6RotShift: opB "rol" shift is opFlag=0 & opShift & opB [ shift = opShift + 1; ] {
    local val:2 = opB << shift;
    val = val | zext(sb);

    # Save shifted out bits in sb
    local tmp = (sb << 8) | opB(1);
    tmp = tmp >> (8 - shift);
    sb = tmp & 0xf:1;

    export val;
}
ALU6RotShift: opB "ror" shift is opFlag=1 & opShift & opB [ shift = opShift + 1; ] {
    local tmpVal:3 = (zext(sb) << 16) | zext(opB);
    tmpVal = tmpVal >> shift;
    local val = tmpVal:2;

    # Save shifted out bits in sb
    local tmp = (opB:1 << 4) | sb;
    tmp = tmp >> shift;
    sb = tmp & 0xf:1;

    export val;
}
ALU6DstStack: ""["bp"+opimm] is op1=0 & opimm {
    # Stack is always located in Bank 0
    local stack_addr:3 = segment(0:1, bp+opimm);
    export *:2 stack_addr;
}

# TODO: do not set flags if destination is PC

# r1 += 7
:^opA += ALU6BaseDisplacement is op0=0 & op1=0 & opA & UnpackSR_opA & ALU6BaseDisplacement {
    local origOpA:2 = opA;
    opA = opA + ALU6BaseDisplacement;
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddFlags(origOpA, ALU6BaseDisplacement);
}
:^opA += ALU6Opimm is op0=0 & op1=1 & opA & UnpackSR_opA & ALU6Opimm {
    local origOpA:2 = opA;
    opA = opA + ALU6Opimm;
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddFlags(origOpA, ALU6Opimm);
}
:^opA += IndirectOp is op0=0 & op1=3 & opA & UnpackSR_opA & IndirectOp {
    local origOpA:2 = opA;
    opA = opA + IndirectOp;
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddFlags(origOpA, IndirectOp);
}
:^opA += ALU6Reg is op0=0 & op1=4 & opN=0 & opA & UnpackSR_opA & ALU6Reg {
    local origOpA:2 = opA;
    opA = opA + ALU6Reg;
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddFlags(origOpA, ALU6Reg);
}
:^opA += ALU6RShift is op0=0 & op1=4 & opFlag=1 & opA & UnpackSR_opA & ALU6RShift {
    local origOpA:2 = opA;
    opA = opA + ALU6RShift;
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddFlags(origOpA, ALU6RShift);
}
:^opA += ALU6LShift is op0=0 & op1=5 & opA & UnpackSR_opA & ALU6LShift {
    local origOpA:2 = opA;
    opA = opA + ALU6LShift;
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddFlags(origOpA, ALU6LShift);
}
:^opA += ALU6RotShift is op0=0 & op1=6 & opA & UnpackSR_opA & ALU6RotShift {
    local origOpA:2 = opA;
    opA = opA + ALU6RotShift;
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddFlags(origOpA, ALU6RotShift);
}
:^opA += ALU6Mem is op0=0 & op1=7 & opA & UnpackSR_opA & ALU6Mem {
    local origOpA:2 = opA;
    opA = opA + ALU6Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddFlags(origOpA, ALU6Mem);
}

# r1 += 7, carry
:^opA += ALU6BaseDisplacement, "carry" is op0=1 & op1=0 & opA & UnpackSR_opA & ALU6BaseDisplacement {
    local origOpA:2 = opA;
    opA = opA + ALU6BaseDisplacement + zext(C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddCarryFlags(origOpA, ALU6BaseDisplacement);
}
:^opA += ALU6Opimm, "carry" is op0=1 & op1=1 & opA & UnpackSR_opA & ALU6Opimm {
    local origOpA:2 = opA;
    opA = opA + ALU6Opimm + zext(C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddCarryFlags(origOpA, ALU6Opimm);
}
:^opA += IndirectOp, "carry" is op0=1 & op1=3 & opA & UnpackSR_opA & IndirectOp {
    local origOpA:2 = opA;
    opA = opA + IndirectOp + zext(C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddCarryFlags(origOpA, IndirectOp);
}
:^opA += ALU6Reg, "carry" is op0=1 & op1=4 & opN=0 & opA & UnpackSR_opA & ALU6Reg {
    local origOpA:2 = opA;
    opA = opA + ALU6Reg + zext(C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddCarryFlags(origOpA, ALU6Reg);
}
:^opA += ALU6RShift, "carry" is op0=1 & op1=4 & opFlag=1 & opA & UnpackSR_opA & ALU6RShift {
    local origOpA:2 = opA;
    opA = opA + ALU6RShift + zext(C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddCarryFlags(origOpA, ALU6RShift);
}
:^opA += ALU6LShift, "carry" is op0=1 & op1=5 & opA & UnpackSR_opA & ALU6LShift {
    local origOpA:2 = opA;
    opA = opA + ALU6LShift + zext(C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddCarryFlags(origOpA, ALU6LShift);
}
:^opA += ALU6RotShift, "carry" is op0=1 & op1=6 & opA & UnpackSR_opA & ALU6RotShift {
    local origOpA:2 = opA;
    opA = opA + ALU6RotShift + zext(C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddCarryFlags(origOpA, ALU6RotShift);
}
:^opA += ALU6Mem, "carry" is op0=1 & op1=7 & opA & UnpackSR_opA & ALU6Mem {
    local origOpA:2 = opA;
    opA = opA + ALU6Mem + zext(C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddCarryFlags(origOpA, ALU6Mem);
}

# r1 -= 7
:^opA -= ALU6BaseDisplacement is op0=2 & op1=0 & opA & UnpackSR_opA & ALU6BaseDisplacement  {
    local origOpA:2 = opA;
    opA = opA - ALU6BaseDisplacement;
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractFlags(origOpA, ALU6BaseDisplacement);
}
:^opA -= ALU6Opimm is op0=2 & op1=1 & opA & UnpackSR_opA & ALU6Opimm  {
    local origOpA:2 = opA;
    opA = opA - ALU6Opimm;
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractFlags(origOpA, ALU6Opimm);
}
:^opA -= IndirectOp is op0=2 & op1=3 & opA & UnpackSR_opA & IndirectOp  {
    local origOpA:2 = opA;
    opA = opA - IndirectOp;
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractFlags(origOpA, IndirectOp);
}
:^opA -= ALU6Reg is op0=2 & op1=4 & opN=0 & opA & UnpackSR_opA & ALU6Reg  {
    local origOpA:2 = opA;
    opA = opA - ALU6Reg;
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractFlags(origOpA, ALU6Reg);
}
:^opA -= ALU6RShift is op0=2 & op1=4 & opFlag=1 & opA & UnpackSR_opA & ALU6RShift  {
    local origOpA:2 = opA;
    opA = opA - ALU6RShift;
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractFlags(origOpA, ALU6RShift);
}
:^opA -= ALU6LShift is op0=2 & op1=5 & opA & UnpackSR_opA & ALU6LShift  {
    local origOpA:2 = opA;
    opA = opA - ALU6LShift;
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractFlags(origOpA, ALU6LShift);
}
:^opA -= ALU6RotShift is op0=2 & op1=6 & opA & UnpackSR_opA & ALU6RotShift  {
    local origOpA:2 = opA;
    opA = opA - ALU6RotShift;
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractFlags(origOpA, ALU6RotShift);
}
:^opA -= ALU6Mem is op0=2 & op1=7 & opA & UnpackSR_opA & ALU6Mem  {
    local origOpA:2 = opA;
    opA = opA - ALU6Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractFlags(origOpA, ALU6Mem);
}
# r1 -= 7, carry
:^opA -= ALU6BaseDisplacement, "carry" is op0=3 & op1=0 & opA & UnpackSR_opA & ALU6BaseDisplacement  {
    local origOpA:2 = opA;
    opA = opA - ALU6BaseDisplacement - zext(!C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractCarryFlags(origOpA, ALU6BaseDisplacement);
}
:^opA -= ALU6Opimm, "carry" is op0=3 & op1=1 & opA & UnpackSR_opA & ALU6Opimm  {
    local origOpA:2 = opA;
    opA = opA - ALU6Opimm - zext(!C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractCarryFlags(origOpA, ALU6Opimm);
}
:^opA -= IndirectOp, "carry" is op0=3 & op1=3 & opA & UnpackSR_opA & IndirectOp  {
    local origOpA:2 = opA;
    opA = opA - IndirectOp - zext(!C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractCarryFlags(origOpA, IndirectOp);
}
:^opA -= ALU6Reg, "carry" is op0=3 & op1=4 & opN=0 & opA & UnpackSR_opA & ALU6Reg  {
    local origOpA:2 = opA;
    opA = opA - ALU6Reg - zext(!C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractCarryFlags(origOpA, ALU6Reg);
}
:^opA -= ALU6RShift, "carry" is op0=3 & op1=4 & opFlag=1 & opA & UnpackSR_opA & ALU6RShift  {
    local origOpA:2 = opA;
    opA = opA - ALU6RShift - zext(!C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractCarryFlags(origOpA, ALU6RShift);
}
:^opA -= ALU6LShift, "carry" is op0=3 & op1=5 & opA & UnpackSR_opA & ALU6LShift  {
    local origOpA:2 = opA;
    opA = opA - ALU6LShift - zext(!C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractCarryFlags(origOpA, ALU6LShift);
}
:^opA -= ALU6RotShift, "carry" is op0=3 & op1=6 & opA & UnpackSR_opA & ALU6RotShift  {
    local origOpA:2 = opA;
    opA = opA - ALU6RotShift - zext(!C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractCarryFlags(origOpA, ALU6RotShift);
}
:^opA -= ALU6Mem, "carry" is op0=3 & op1=7 & opA & UnpackSR_opA & ALU6Mem  {
    local origOpA:2 = opA;
    opA = opA - ALU6Mem - zext(!C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractCarryFlags(origOpA, ALU6Mem);
}

# cmp r1, 7
:cmp opARead, ALU6BaseDisplacement is op0=4 & op1=0 & opARead & ALU6BaseDisplacement  {
    local res = opARead - ALU6BaseDisplacement;
    setResultFlags(res);
    setSubtractFlags(opARead, ALU6BaseDisplacement);
}
:cmp opARead, ALU6Opimm is op0=4 & op1=1 & opARead & ALU6Opimm  {
    local res = opARead - ALU6Opimm;
    setResultFlags(res);
    setSubtractFlags(opARead, ALU6Opimm);
}
:cmp opARead, IndirectOp is op0=4 & op1=3 & opARead & IndirectOp  {
    local res = opARead - IndirectOp;
    setResultFlags(res);
    setSubtractFlags(opARead, IndirectOp);
}
:cmp opARead, ALU6Reg is op0=4 & op1=4 & opN=0 & opARead & ALU6Reg  {
    local res = opARead - ALU6Reg;
    setResultFlags(res);
    setSubtractFlags(opARead, ALU6Reg);
}
:cmp opARead, ALU6RShift is op0=4 & op1=4 & opFlag=1 & opARead & ALU6RShift  {
    local res = opARead - ALU6RShift;
    setResultFlags(res);
    setSubtractFlags(opARead, ALU6RShift);
}
:cmp opARead, ALU6LShift is op0=4 & op1=5 & opARead & ALU6LShift  {
    local res = opARead - ALU6LShift;
    setResultFlags(res);
    setSubtractFlags(opARead, ALU6LShift);
}
:cmp opARead, ALU6RotShift is op0=4 & op1=6 & opARead & ALU6RotShift  {
    local res = opARead - ALU6RotShift;
    setResultFlags(res);
    setSubtractFlags(opARead, ALU6RotShift);
}
:cmp opARead, ALU6Mem is op0=4 & op1=7 & opARead & ALU6Mem  {
    local res = opARead - ALU6Mem;
    setResultFlags(res);
    setSubtractFlags(opARead, ALU6Mem);
} 
# r1 = -7
:^opA = -ALU6BaseDisplacement is op0=6 & op1=0 & opA & UnpackSR_opA & ALU6BaseDisplacement  {
    opA = -ALU6BaseDisplacement;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = -ALU6Opimm is op0=6 & op1=1 & opA & UnpackSR_opA & ALU6Opimm  {
    opA = -ALU6Opimm;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = -IndirectOp is op0=6 & op1=3 & opA & UnpackSR_opA & IndirectOp  {
    opA = -IndirectOp;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = -ALU6Reg is op0=6 & op1=4 & opN=0 & opA & UnpackSR_opA & ALU6Reg  {
    opA = -ALU6Reg;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = -ALU6RShift is op0=6 & op1=4 & opFlag=1 & opA & UnpackSR_opA & ALU6RShift  {
    opA = -ALU6RShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = -ALU6LShift is op0=6 & op1=5 & opA & UnpackSR_opA & ALU6LShift  {
    opA = -ALU6LShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = -ALU6RotShift is op0=6 & op1=6 & opA & UnpackSR_opA & ALU6RotShift  {
    opA = -ALU6RotShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = -ALU6Mem is op0=6 & op1=7 & opA & UnpackSR_opA & ALU6Mem  {
    opA = -ALU6Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
}
# r1 ^= 7
:^opA "^"= ALU6BaseDisplacement is op0=8 & op1=0 & opA & UnpackSR_opA & ALU6BaseDisplacement  {
    opA = opA ^ ALU6BaseDisplacement;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA "^"= ALU6Opimm is op0=8 & op1=1 & opA & UnpackSR_opA & ALU6Opimm  {
    opA = opA ^ ALU6Opimm;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA "^"= IndirectOp is op0=8 & op1=3 & opA & UnpackSR_opA & IndirectOp  {
    opA = opA ^ IndirectOp;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA "^"= ALU6Reg is op0=8 & op1=4 & opN=0 & opA & UnpackSR_opA & ALU6Reg  {
    opA = opA ^ ALU6Reg;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA "^"= ALU6RShift is op0=8 & op1=4 & opFlag=1 & opA & UnpackSR_opA & ALU6RShift  {
    opA = opA ^ ALU6RShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA "^"= ALU6LShift is op0=8 & op1=5 & opA & UnpackSR_opA & ALU6LShift  {
    opA = opA ^ ALU6LShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA "^"= ALU6RotShift is op0=8 & op1=6 & opA & UnpackSR_opA & ALU6RotShift  {
    opA = opA ^ ALU6RotShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA "^"= ALU6Mem is op0=8 & op1=7 & opA & UnpackSR_opA & ALU6Mem  {
    opA = opA ^ ALU6Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
}

# r1 = 7
:^opA = ALU6BaseDisplacement is op0=9 & op1=0 & opA & UnpackSR_opA & ALU6BaseDisplacement  {
    opA = ALU6BaseDisplacement;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = ALU6Opimm is op0=9 & op1=1 & opA & UnpackSR_opA & ALU6Opimm  {
    opA = ALU6Opimm;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = IndirectOp is op0=9 & op1=3 & opA & UnpackSR_opA & IndirectOp  {
    opA = IndirectOp;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = ALU6Reg is op0=9 & op1=4 & opN=0 & opA & UnpackSR_opA & ALU6Reg  {
    opA = ALU6Reg;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = ALU6RShift is op0=9 & op1=4 & opFlag=1 & opA & UnpackSR_opA & ALU6RShift  {
    opA = ALU6RShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = ALU6LShift is op0=9 & op1=5 & opA & UnpackSR_opA & ALU6LShift  {
    opA = ALU6LShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = ALU6RotShift is op0=9 & op1=6 & opA & UnpackSR_opA & ALU6RotShift  {
    opA = ALU6RotShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = ALU6Mem is op0=9 & op1=7 & opA & UnpackSR_opA & ALU6Mem  {
    opA = ALU6Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
}
# r1 |= 7
:^opA |= ALU6BaseDisplacement is op0=0xa & op1=0 & opA & UnpackSR_opA & ALU6BaseDisplacement  {
    opA = opA | ALU6BaseDisplacement;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA |= ALU6Opimm is op0=0xa & op1=1 & opA & UnpackSR_opA & ALU6Opimm  {
    opA = opA | ALU6Opimm;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA |= IndirectOp is op0=0xa & op1=3 & opA & UnpackSR_opA & IndirectOp  {
    opA = opA | IndirectOp;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA |= ALU6Reg is op0=0xa & op1=4 & opN=0 & opA & UnpackSR_opA & ALU6Reg  {
    opA = opA | ALU6Reg;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA |= ALU6RShift is op0=0xa & op1=4 & opFlag=1 & opA & UnpackSR_opA & ALU6RShift  {
    opA = opA | ALU6RShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA |= ALU6LShift is op0=0xa & op1=5 & opA & UnpackSR_opA & ALU6LShift  {
    opA = opA | ALU6LShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA |= ALU6RotShift is op0=0xa & op1=6 & opA & UnpackSR_opA & ALU6RotShift  {
    opA = opA | ALU6RotShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA |= ALU6Mem is op0=0xa & op1=7 & opA & UnpackSR_opA & ALU6Mem  {
    opA = opA | ALU6Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
}
# r1 &= 7
:^opA &= ALU6BaseDisplacement is op0=0xb & op1=0 & opA & UnpackSR_opA & ALU6BaseDisplacement  {
    opA = opA & ALU6BaseDisplacement;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA &= ALU6Opimm is op0=0xb & op1=1 & opA & UnpackSR_opA & ALU6Opimm  {
    opA = opA & ALU6Opimm;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA &= IndirectOp is op0=0xb & op1=3 & opA & UnpackSR_opA & IndirectOp  {
    opA = opA & IndirectOp;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA &= ALU6Reg is op0=0xb & op1=4 & opN=0 & opA & UnpackSR_opA & ALU6Reg  {
    opA = opA & ALU6Reg;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA &= ALU6RShift is op0=0xb & op1=4 & opFlag=1 & opA & UnpackSR_opA & ALU6RShift  {
    opA = opA & ALU6RShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA &= ALU6LShift is op0=0xb & op1=5 & opA & UnpackSR_opA & ALU6LShift  {
    opA = opA & ALU6LShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA &= ALU6RotShift is op0=0xb & op1=6 & opA & UnpackSR_opA & ALU6RotShift  {
    opA = opA & ALU6RotShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA &= ALU6Mem is op0=0xb & op1=7 & opA & UnpackSR_opA & ALU6Mem  {
    opA = opA & ALU6Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
}
# test r1, 7
:test opARead, ALU6BaseDisplacement is op0=0xc & op1=0 & opARead & ALU6BaseDisplacement  {
    local res = opARead & ALU6BaseDisplacement;
    setResultFlags(res);
}
:test opARead, ALU6Opimm is op0=0xc & op1=1 & opARead & ALU6Opimm  {
    local res = opARead & ALU6Opimm;
    setResultFlags(res);
}
:test opARead, IndirectOp is op0=0xc & op1=3 & opARead & IndirectOp  {
    local res = opARead & IndirectOp;
    setResultFlags(res);
}
:test opARead, ALU6Reg is op0=0xc & op1=4 & opN=0 & opARead & ALU6Reg  {
    local res = opARead & ALU6Reg;
    setResultFlags(res);
}
:test opARead, ALU6RShift is op0=0xc & op1=4 & opFlag=1 & opARead & ALU6RShift  {
    local res = opARead & ALU6RShift;
    setResultFlags(res);
}
:test opARead, ALU6LShift is op0=0xc & op1=5 & opARead & ALU6LShift  {
    local res = opARead & ALU6LShift;
    setResultFlags(res);
}
:test opARead, ALU6RotShift is op0=0xc & op1=6 & opARead & ALU6RotShift  {
    local res = opARead & ALU6RotShift;
    setResultFlags(res);
}
:test opARead, ALU6Mem is op0=0xc & op1=7 & opARead & ALU6Mem  {
    local res = opARead & ALU6Mem;
    setResultFlags(res);
}
# [bp+7] = r1
:^ALU6DstStack = opARead is op0=0xd & op1=0 & opARead & ALU6DstStack  {
   ALU6DstStack = opARead;
    # does not update flags
}
:^IndirectOp = opARead is op0=0xd & op1=3 & opARead & IndirectOp  {
   IndirectOp = opARead;
}

# [0] = r1
:[opimm] = opARead is op0=0xd & op1=7 & opARead & opimm {
    local addr:3 = opimm;
    *:2 addr = opARead;
}

StackOpA: ""[opARead] is opARead {
    export *:2 opARead;
}
DataOpA: "ds:"[opARead] is opARead {
    local addr:3 = segment(ds, opARead);
    export *:2 addr;
}

# Otherwise cannot be distinguished. Cannot put in directly because
# wrong type (should be family) in pattern equation
with : opA_v!=7 { 
    # Bit Manipulation
    # Test bit
    :tstb opARead, opBitN is op0=0xe & op1=1 & opBitFn=0 & opBitN & opARead {
        local mask = 1 << opBitN;
        Z_flag = (opARead & mask) == 0;
    }
    :tstb StackOpA, opB is op0=0xe & op1=4 & opBitFn=0 & opBitFlg=0 & opB & StackOpA {
        local mask = 1 << opB;
        Z_flag = (StackOpA & mask) == 0;
    }
    :tstb DataOpA, opB is op0=0xe & op1=5 & opBitFn=0 & opBitFlg=0 & opB & DataOpA {
        local mask = 1 << opB;
        Z_flag = (DataOpA & mask) == 0;
    }
    :tstb StackOpA, opBitN is op0=0xe & op1=6 & opBitFn=0 & opBitN & StackOpA {
        local mask = 1 << opBitN;
        Z_flag = (StackOpA & mask) == 0;
    }
    :tstb DataOpA, opBitN is op0=0xe & op1=7 & opBitFn=0 & opBitN & DataOpA {
        local mask = 1 << opBitN;
        Z_flag = (DataOpA & mask) == 0;
    }
    # Set bit
    :setb opARead, opBitN is op0=0xe & op1=1 & opBitFn=1 & opBitN & opARead & UnpackSR_opA { 
        local mask = 1 << opBitN;
        opARead = opARead | mask;
        build UnpackSR_opA;
    }
    :setb StackOpA, opB is op0=0xe & op1=4 & opBitFn=1 & opBitFlg=0 & opB & StackOpA { 
        local mask = 1 << opB;
        StackOpA = StackOpA | mask;
    }
    :setb DataOpA, opB is op0=0xe & op1=5 & opBitFn=1 & opBitFlg=0 & opB & DataOpA { 
        local mask = 1 << opB;
        DataOpA = DataOpA | mask;
    }
    :setb StackOpA, opBitN is op0=0xe & op1=6 & opBitFn=1 & opBitN & StackOpA { 
        local mask = 1 << opBitN;
        StackOpA = StackOpA | mask;
    }
    :setb DataOpA, opBitN is op0=0xe & op1=7 & opBitFn=1 & opBitN & DataOpA { 
        local mask = 1 << opBitN;
        DataOpA = DataOpA | mask;
    }
    # Clear bit
    :clrb opARead, opBitN is op0=0xe & op1=1 & opBitFn=2 & opBitN & opARead & UnpackSR_opA {
        local mask = 1 << opBitN;
        opARead = opARead & ~mask;
        build UnpackSR_opA;
    }
    :clrb StackOpA, opB is op0=0xe & op1=4 & opBitFn=2 & opBitFlg=0 & opB & StackOpA {
        local mask = 1 << opB;
        StackOpA = StackOpA & ~mask;
    }
    :clrb DataOpA, opB is op0=0xe & op1=5 & opBitFn=2 & opBitFlg=0 & opB & DataOpA {
        local mask = 1 << opB;
        DataOpA = DataOpA & ~mask;
    }
    :clrb StackOpA, opBitN is op0=0xe & op1=6 & opBitFn=2 & opBitN & StackOpA {
        local mask = 1 << opBitN;
        StackOpA = StackOpA & ~mask;
    }
    :clrb DataOpA, opBitN is op0=0xe & op1=7 & opBitFn=2 & opBitN & DataOpA {
        local mask = 1 << opBitN;
        DataOpA = DataOpA & ~mask;
    }
    # Toggle bit
    :invb opARead, opBitN is op0=0xe & op1=1 & opBitFn=3 & opBitN & opARead & UnpackSR_opA {
        local mask = 1 << opBitN;
        opARead = opARead ^ mask;
        build UnpackSR_opA;
    }
    :invb StackOpA, opB is op0=0xe & op1=4 & opBitFn=3 & opBitFlg=0 & opB & StackOpA {
        local mask = 1 << opB;
        StackOpA = StackOpA ^ mask;
    }
    :invb DataOpA, opB is op0=0xe & op1=5 & opBitFn=3 & opBitFlg=0 & opB & DataOpA {
        local mask = 1 << opB;
        DataOpA = DataOpA ^ mask;
    }
    :invb StackOpA, opBitN is op0=0xe & op1=6 & opBitFn=3 & opBitN & StackOpA {
        local mask = 1 << opBitN;
        StackOpA = StackOpA ^ mask;
    }
    :invb DataOpA, opBitN is op0=0xe & op1=7 & opBitFn=3 & opBitN & DataOpA {
        local mask = 1 << opBitN;
        DataOpA = DataOpA ^ mask;
    }
}

StackOpA16: ""[imm16] is imm16 {
    export *:2 imm16;
}

DataOpA16: "ds:"[imm16] is imm16 {
    local addr:3 = segment(ds, imm16:2);
    export *:2 addr;
}

# Register BITOP
:tstb opA, opB is op0 = 0xe & opA & op1=0 & opBitFlg=0 & opBitFn=0 & opB {
    local mask = 1 << opB;
    Z_flag = (opA & mask) == 0;
}

:setb opA, opB is op0 = 0xe & opA & op1=0 & opBitFlg=0 & opBitFn=1 & opB {
    local mask = 1 << opB;
    opA = opA | mask;
}

:clrb opA, opB is op0 = 0xe & opA & op1=0 & opBitFlg=0 & opBitFn=2 & opB {
    local mask = 1 << opB;
    opA = opA & ~mask;
}

:invb opA, opB is op0 = 0xe & opA & op1=0 & opBitFlg=0 & opBitFn=3 & opB {
    local mask = 1 << opB;
    opA = opA ^ mask;
}

# Memory BITOP A16, u'nSP 2.0
:tstb StackOpA16, opBitN is opA_9=1 & opA_10=0 & op1=1 & opBitFn=0 & opBitN ; StackOpA16 {
    local mask = 1 << opBitN;
    Z_flag = (StackOpA16 & mask) == 0;
}
:tstb DataOpA16, opBitN is opA_9=1 & opA_10=1 & op1=1 & opBitFn=0 & opBitN ; DataOpA16 {
    local mask = 1 << opBitN;
    Z_flag = (DataOpA16 & mask) == 0;
}
:setb StackOpA16, opBitN is opA_9=1 & opA_10=0 & op1=1 & opBitFn=1 & opBitN ; StackOpA16 {
    local mask = 1 << opBitN;
    StackOpA16 = StackOpA16 | mask;
}
:setb DataOpA16, opBitN is opA_9=1 & opA_10=1 & op1=1 & opBitFn=1 & opBitN ; DataOpA16 {
    local mask = 1 << opBitN;
    DataOpA16 = DataOpA16 | mask;
}
:clrb StackOpA16, opBitN is opA_9=1 & opA_10=0 & op1=1 & opBitFn=2 & opBitN ; StackOpA16 {
    local mask = 1 << opBitN;
    StackOpA16 = StackOpA16 & ~mask;
}
:clrb DataOpA16, opBitN is opA_9=1 & opA_10=1 & op1=1 & opBitFn=2 & opBitN ; DataOpA16 {
    local mask = 1 << opBitN;
    DataOpA16 = DataOpA16 & ~mask;
}
:invb StackOpA16, opBitN is opA_9=1 & opA_10=0 & op1=1 & opBitFn=3 & opBitN ; StackOpA16 {
    local mask = 1 << opBitN;
    StackOpA16 = StackOpA16 ^ mask;
}
:invb DataOpA16, opBitN is opA_9=1 & opA_10=1 & op1=1 & opBitFn=3 & opBitN ; DataOpA16 {
    local mask = 1 << opBitN;
    DataOpA16 = DataOpA16 ^ mask;
}

Bank0Mem: ""[imm16] is imm16 { export *:2 imm16; }

# ALU16
# TODO: this opA_v!=7 isn't true for all cases, should move to specific ALU6Terms after inspection
# with : (op0!=0xf & op0!=0xe & op1=4 & (opN=1 | opN=2 | opN=3)) ... {

# r1 = r2 + 0x1234
# This trickery makes the assembler suggest impossible instructions...
# like [0x1234] = r2 + [0x1234]
# It won't crash or produce invalid machine code. Merely a UX problem
:^opA = opB + imm16 is (op0=0 & op1=4 & opN=1 & opA & UnpackSR_opA & opB) ; imm16 {
	opA = opB + imm16;
    build UnpackSR_opA;
	setResultFlags(opA);
	setAddFlags(opB, imm16);
}
:^opA = opB + Bank0Mem is (op0=0 & op1=4 & opN=2 & opA & UnpackSR_opA & opB) ; Bank0Mem {
	opA = opB + Bank0Mem;
    build UnpackSR_opA;
	setResultFlags(opA);
	setAddFlags(opB, Bank0Mem);
}
:^Bank0Mem = opB + opA is (op0=0 & op1=4 & opN=3 & opA & opB) ; Bank0Mem {
	Bank0Mem = opB + opA;
	setResultFlags(Bank0Mem);
	setAddFlags(opB, opA);
}
# r1 = r2 + 0x1234, carry
:^opA = opB + imm16, "carry" is (op0=1 & op1=4 & opN=1 & opA & UnpackSR_opA & opB) ; imm16 {
    opA = opB + imm16 + zext(C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddCarryFlags(opB, imm16);
}
:^opA = opB + Bank0Mem, "carry" is (op0=1 & op1=4 & opN=2 & opA & UnpackSR_opA & opB) ; Bank0Mem {
    opA = opB + Bank0Mem + zext(C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddCarryFlags(opB, Bank0Mem);
}
:^Bank0Mem = opB + opA, "carry" is (op0=1 & op1=4 & opN=3 & opA & opB) ; Bank0Mem {
    Bank0Mem = opB + opA + zext(C_flag);
    setResultFlags(Bank0Mem);
    setAddCarryFlags(opB, opA);
}
# r1 = r2 - 0x1234
:^opA = opB - imm16 is (op0=2 & op1=4 & opN=1 & opA & UnpackSR_opA & opB) ; imm16 {
    opA = opB - imm16;
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractFlags(opB, imm16);
}
:^opA = opB - Bank0Mem is (op0=2 & op1=4 & opN=2 & opA & UnpackSR_opA & opB) ; Bank0Mem {
    opA = opB - Bank0Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractFlags(opB, Bank0Mem);
}
:^Bank0Mem = opB - opA is (op0=2 & op1=4 & opN=3 & opA & opB) ; Bank0Mem {
    Bank0Mem = opB - opA;
    setResultFlags(Bank0Mem);
    setSubtractFlags(opB, opA);
}
# r1 = r2 - 0x1234, carry
:^opA = opB - imm16, "carry" is (op0=3 & op1=4 & opN=1 & opA & UnpackSR_opA & opB) ; imm16 {
    opA = opB - imm16 - zext(!C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractCarryFlags(opB, imm16);
}
:^opA = opB - Bank0Mem, "carry" is (op0=3 & op1=4 & opN=2 & opA & UnpackSR_opA & opB) ; Bank0Mem {
    opA = opB - Bank0Mem - zext(!C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractCarryFlags(opB, Bank0Mem);
}
:^Bank0Mem = opB - opA, "carry" is (op0=3 & op1=4 & opN=3 & opA & opB) ; Bank0Mem {
    Bank0Mem = opB - opA - zext(!C_flag);
    setResultFlags(Bank0Mem);
    setSubtractCarryFlags(opB, opA);
}
# cmp r2, 0x1234
:cmp opB, imm16 is (op0=4 & op1=4 & opN=1 & opA & opB) ; imm16 {
    local res = opB - imm16;
    setResultFlags(res);
    setSubtractCarryFlags(opB, imm16);
}
:cmp opB, Bank0Mem is (op0=4 & op1=4 & opN=2 & opA & opB) ; Bank0Mem {
    local res = opB - Bank0Mem;
    setResultFlags(res);
    setSubtractCarryFlags(opB, Bank0Mem);
}
# r1 = -0x1234
:^opA = -imm16 is (op0=6 & op1=4 & opN=1 & opA & UnpackSR_opA) ; imm16 {
    opA = -imm16;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = -Bank0Mem is (op0=6 & op1=4 & opN=2 & opA & UnpackSR_opA) ; Bank0Mem {
    opA = -Bank0Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^Bank0Mem = -opARead is (op0=6 & op1=4 & opN=3 & opARead) ; Bank0Mem {
    Bank0Mem = -opARead;
    setResultFlags(Bank0Mem);
}
# r1 = r2 ^ 0x1234
:^opA = opB "^" imm16 is (op0=8 & op1=4 & opN=1 & opA & UnpackSR_opA & opB) ; imm16 {
    opA = opB ^ imm16;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = opB "^" Bank0Mem is (op0=8 & op1=4 & opN=2 & opA & UnpackSR_opA & opB) ; Bank0Mem {
    opA = opB ^ Bank0Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^Bank0Mem = opB "^" opARead is (op0=8 & op1=4 & opN=3 & opARead & opB) ; Bank0Mem {
    Bank0Mem = opB ^ opARead;
    setResultFlags(Bank0Mem);
}
# r1 = 0x1234
:^opA = imm16 is (op0=9 & op1=4 & opN=1 & opA & UnpackSR_opA) ; imm16 {
    opA = imm16;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^"pc" = imm16 is (op0=9 & op1=4 & opN=1 & opA_v=7) ; imm16 {
	local off:2 = imm16;
	# inst_start is 8 bit byte, not word offset, need to load PC with word offset
	local addr:3= ((inst_start >> 1) & 0xff0000) | zext(off);
    setResultFlags(off);
    goto [addr];
}
:^opA = Bank0Mem is (op0=9 & op1=4 & opN=2 & opA & UnpackSR_opA) ; Bank0Mem {
    opA = Bank0Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^Bank0Mem = opARead is (op0=9 & op1=4 & opN=3 & opARead) ; Bank0Mem {
    Bank0Mem = opARead;
    setResultFlags(Bank0Mem);
}
# r1 = r2 | 0x1234
:^opA = opB | imm16 is (op0=0xa & op1=4 & opN=1 & opA & UnpackSR_opA & opB) ; imm16 {
    opA = opB | imm16;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = opB | Bank0Mem is (op0=0xa & op1=4 & opN=2 & opA & UnpackSR_opA & opB) ; Bank0Mem {
    opA = opB | Bank0Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^Bank0Mem = opB | opARead is (op0=0xa & op1=4 & opN=3 & opARead & opB) ; Bank0Mem {
    Bank0Mem = opB | opARead;
    setResultFlags(Bank0Mem);
}
# r1 = r2 & 0x1234
:^opA = opB & imm16 is (op0=0xb & op1=4 & opN=1 & opA & UnpackSR_opA & opB) ; imm16 {
    opA = opB & imm16;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = opB & Bank0Mem is (op0=0xb & op1=4 & opN=2 & opA & UnpackSR_opA & opB) ; Bank0Mem {
    opA = opB & Bank0Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^Bank0Mem = opB & opARead is (op0=0xb & op1=4 & opN=3 & opARead & opB) ; Bank0Mem {
    Bank0Mem = opB & opARead;
    setResultFlags(Bank0Mem);
}
# test r2, 0x1234
# Note: xasm16 says using SR as source register is illegal
:test opB_nosr, imm16 is (op0=0xc & op1=4 & opN=1 & opA & opB_nosr) ; imm16 {
    local res = opB_nosr & imm16;
    setResultFlags(res);
}
:test opB_nosr, Bank0Mem is (op0=0xc & op1=4 & opN=2 & opA & opB_nosr) ; Bank0Mem {
    local res = opB_nosr & Bank0Mem;
    setResultFlags(res);
}
# [0x1234] = r2
:^Bank0Mem = opB is (op0=0xd & op1=4 & opN=3 & opB) ; Bank0Mem {
    Bank0Mem = opB;
    # does not update flags
}

# Interrupts, nop, and others
# TODO opA == 0 ??
# TODO Basing this on opimm isn't right...
# Seems to switch on opB (literal not register)
# Revisit
with : op1=5 & op0=0xf {
    :int "off" is opimm=0x00 {
        irq = 0;
        fiq = 0;
    }
    :int "irq" is opimm=0x01 {
        irq = 1;
        fiq = 0;
    }
    :int "fiq" is opimm=0x02 {
        irq = 0;
        fiq = 1;
    }
    :int "fiq,irq" is opimm=0x03 {
        irq = 1;
        fiq = 1;
    }
    :fir_mov "on" is opimm=0x04 {
        fir_mov = 0;
    }
    :fir_mov "off" is opimm=0x05 {
        fir_mov = 1;
    }
    :fraction "off" is opimm=0x06 {
        fraction = 0;
    }
    :fraction "on" is opimm=0x07 {
        fraction = 1;
    }
    :irq "off" is opimm=0x08 {
        irq = 0;
    }
    :irq "on" is opimm=0x09 {
        irq = 1;
    }
    :secbank "off" is opimm=0x0a {
        sec_bank = 0;
    }
    :secbank "on" is opimm=0x0b {
        sec_bank = 1;
    }
    :fiq "off" is opimm=0x0c {
        fiq = 0;
    }
    :irqnest "off" is opimm=0x0d {
        irqnest = 0;
    }
    :fiq "on" is opimm=0x0e {
        fiq = 1;
    }
    :irqnest "on" is opimm=0x0f {
        irqnest = 1;
    }
    :"break" is opimm=0x20 unimpl
    :"call mr" is opimm=0x21 {
        push(pc);
        push(sr);

        local addr:3 = segment(r4 & 0x3f, r3);
        call [addr];
    }
    :^"exp(r2, r4)" is opimm=0x24 {
        r2 = exp(r4);
    }
    :"nop" is opimm=0x25 {
        # To suppress NOP warning
        local NOP:1 = 0;
        NOP = NOP;
    }
}

# Extra Shifts
with : op0=0xe & opE1=2 & opBitFlg=1 {
    # 1110|***|100|00|1|***
    :^opARead "asr" opB is opE2=0 & opARead & UnpackSR_opA & opB {
        opARead = opARead s>> opB;
        build UnpackSR_opA;
    }
    # 1110|***|100|10|1|***
    :^opARead "lsl" opB is opE2=2 & opARead & UnpackSR_opA & opB {
        opARead = opARead << opB;
        build UnpackSR_opA;
    }
    # 1110|***|101|00|1|***
    :^opARead "lsr" opB is opE2=4 & opARead & UnpackSR_opA & opB {
        opARead = opARead >> opB;
        build UnpackSR_opA;
    }
    # 1110|***|100|01|1|***
    :^"r3,r4" |= opARead "asror" opB is opE2=1 & opARead & opB {
        if(opB==0) goto inst_next;
        local full:4 = sext(opARead) << 16;
        full = full s>> opB;
        r3 = r3 | full:2;
        r4 = opARead s>> opB;
    }
    # 1110|***|10|01|11|***
    # Might change display
    :^"r3,r4" |= opARead "lslor" opB is opE2=3 & opARead & opB {
        if(opB==0) goto inst_next;
        local full:4 = zext(opARead) << opB;
        r4 = r4 | full(2);
        r3 = opARead << opB;
    }
    # 1110|***|10|10|11|***
    :^"r3,r4" |= opARead "lsror" opB is opE2=5 & opARead & opB {
        if(opB==0) goto inst_next;
        local full:4 = zext(opARead) << 16;
        full = full >> opB;
        r3 = r3 | full:2;
        r4 = opARead >> opB;
    }
}

# Multiplication
# 1110|***|00|00|01|***
:"mr" = opA*opB, "uu" is op0=0xe & op1=0x0 & opN=0x1 & opA_v!=7 & opA & opB {
    local res:4 = zext(opA) * zext(opB);
    r4 = res(2);
    r3 = res:2;
}
# 1111|***|00|00|01|***
:"mr" = opA*opB, "us" is op0=0xf & op1=0x0 & opN=0x1 & opA_v!=7 & opA & opB {
    local res:4 = zext(opA) * sext(opB);
    r4 = res(2);
    r3 = res:2;
}
# 1111|***|10|00|01|***
:"mr" = opA*opB, "ss" is op0=0xf & op1=0x4 & opN=0x1 & opA_v!=7 & opA & opB {
    local res:4 = sext(opA) * sext(opB);
    r4 = res(2);
    r3 = res:2;
}

opMulSizeStr: "16" is opMulSize = 0 {
    local size:1 = 16;
    export size;
}
opMulSizeStr: "1" is opMulSize {
    local size:1 = opMulSize;
    export size;
}

# inner product
# 85 f3
# [ '1111', '0011', '1000', '0101' ]
:"mr" = [opA] * [opB], "uu", opMulSizeStr is op0=0xe & opE1=0x1 & opA & opB & opMulSizeStr & opA_v != 7 {
    local opASigned:1 = 0;
    local opBSigned:1 = 0;
    local opAAddr:3 = segment(0:1, opA);
    local opBAddr:3 = segment(0:1, opB);
    local res:4 = muls(opAAddr, opASigned, opBAddr, opBSigned, opMulSizeStr);
    r3 = res:2;
}

:"mr" = [opA] * [opB], "us", opMulSizeStr is op0=0xf & opE1=0x1 & opA & opB & opMulSizeStr & opA_v != 7 {
    local opASigned:1 = 0;
    local opBSigned:1 = 1;
    local opAAddr:3 = segment(0:1, opA);
    local opBAddr:3 = segment(0:1, opB);
    local res:4 = muls(opAAddr, opASigned, opBAddr, opBSigned, opMulSizeStr);
    r4 = res(2);
    r3 = res:2;
}

:"mr" = [opA] * [opB], "ss", opMulSizeStr is op0=0xf & opE1=0x3 & opA & opB & opMulSizeStr & opA_v != 7 {
    local opASigned:1 = 1;
    local opBSigned:1 = 1;
    local opAAddr:3 = segment(0:1, opA);
    local opBAddr:3 = segment(0:1, opB);
    local res:4 = muls(opAAddr, opASigned, opBAddr, opBSigned, opMulSizeStr);
    r4 = res(2);
    r3 = res:2;
}


# TODO: division

# Other
# 1111|111|000|******
:^"ds" = opimm is op0=0xf & op1=0 & opA_v=7 & opimm {
    ds = opimm;
}
# 1111|***|000|101|***
:^"ds" = opB_nosr is op0=0xf & op1=0 & opA_v!=7 & opN=5 & opB_nosr {
    ds = opB_nosr:1 & 0x3f;
}
# 1111|***|000|100|***
:^opB_nosr = "ds" is op0=0xf & op1=0 & opA_v!=7 & opN=4 & opB_nosr {
    opB_nosr = zext(ds & 0x3f);
}
# 1111|***|000|111|***
:^"fr" = opB_nosr is op0=0xf & op1=0 & opA_v!=7 & opN=7 & opB_nosr {
    fr = opB_nosr;
}
# 1111|***|000|110|***
:^opB_nosr = "fr" is op0=0xf & op1=0 & opA_v!=7 & opN=6 & opB_nosr {
    opB_nosr = fr;
}

# Calls
call_addr: addr is opimm & op1=1 & op0=0xf; imm16 [ addr=(opimm << 16) | imm16; ] { export *[ram]:3 addr; }

:call call_addr is call_addr {
    # inst_next is in ConstantSpace, which has fixed word size 1
    # This causes all of our addresses to be doubled and generates invalid
    # references to an address, so we need to convert the address before
    # pushing to stack.
    local inst_next_real:3 = inst_next >> 1;
    push(inst_next_real:2);
    sr[0, 6] = inst_next_real[16, 6];
    push(sr);

    call call_addr;
}

goto_addr: addr is op1=2 & op0=0xf & opimm ; imm16 [ addr=(opimm << 16) | imm16; ] { export *[ram]:3 addr; } 

:goto goto_addr is goto_addr {
    goto goto_addr;
}

:goto "mr" is op1=3 & op0=0xf {
    local addr:3 = segment(r4 & 0x3f, r3);
    goto [addr];
}

# TODO tricky to implement, will partially implement for now
:pop opA_p "from" [opB] is op1=2 & op0=9 & opN=1 & opA_p & opB {
    opB = opB + 1;
    local stack_addr:3 = segment(0:1, opB);
    opA_p = *:2 stack_addr;
}
# pop pc, sr from [sp]
:retf is op1=2 & op0=9 & opA_v=5 & opN=2 & opB_v=0 & UnpackSR {
    sp = sp + 1;
    local stack_addr:3 = segment(0:1, sp);
    sr = *:2 stack_addr;
    build UnpackSR;
    sp = sp + 1;
    stack_addr = segment(0:1, sp);
    local pc_low:2 = *:2 stack_addr;
    local addr:3 = segment(cs, pc_low);
    return [addr];
}

:reti is op1=2 & op0=9 & opA_v=5 & opN=3 & opB_v=0 & UnpackSR {
    sp = sp + 1;
    local stack_addr:3 = segment(0:1, sp);
    sr = *:2 stack_addr;
    build UnpackSR;
    sp = sp + 1;
    stack_addr = segment(0:1, sp);
    local pc_low:2 = *:2 stack_addr;
    local addr:3 = segment(cs, pc_low);
    return [addr];
}

:pop "pc", "bp" "from" ["sp"] is op1=2 & op0=9 & opA_v=4 & opN=3 & opB_v=0 & UnpackSR {
    sp = sp + 1;
    local stack_addr:3 = segment(0:1, sp);
    bp = *:2 stack_addr;
    sp = sp + 1;
    stack_addr = segment(0:1, sp);
    sr = *:2 stack_addr;
    build UnpackSR;
    sp = sp + 1;
    stack_addr = segment(0:1, sp);
    local pc_low:2 = *:2 stack_addr;
    local addr:3 = segment(cs, pc_low);
    return [addr];
}

:pop opA_p2,2 "from" [opB] is op1=2 & op0=9 & opN=2 & opA_p & opA_p2 & opB {
    # Pop step
    opB = opB + 1;
    local stack_addr:3 = segment(0:1, opB);
    opA_p = *:2 stack_addr;

    # Pop step
    opB = opB + 1;
    stack_addr = segment(0:1, opB);
    opA_p2 = *:2 stack_addr;
}

:pop opA_p3,3 "from" [opB] is op1=2 & op0=9 & opN=3 & opA_p & opA_p2 & opA_p3 & opB {
    # Pop step
    opB = opB + 1;
    local stack_addr:3 = segment(0:1, opB);
    opA_p = *:2 stack_addr;

    # Pop step
    opB = opB + 1;
    stack_addr = segment(0:1, opB);
    opA_p2 = *:2 stack_addr;

    # Pop step
    opB = opB + 1;
    stack_addr = segment(0:1, opB);
    opA_p3 = *:2 stack_addr;
}

:pop opA_p4,4 "from" [opB] is op1=2 & op0=9 & opN=4 & opA_p & opA_p2 & opA_p3 & opA_p4 & opB {
    # Pop step
    opB = opB + 1;
    local stack_addr:3 = segment(0:1, opB);
    opA_p = *:2 stack_addr;

    # Pop step
    opB = opB + 1;
    stack_addr = segment(0:1, opB);
    opA_p2 = *:2 stack_addr;

    # Pop step
    opB = opB + 1;
    stack_addr = segment(0:1, opB);
    opA_p3 = *:2 stack_addr;

    # Pop step
    opB = opB + 1;
    stack_addr = segment(0:1, opB);
    opA_p4 = *:2 stack_addr;
}

:pop opA_p5,5 "from" [opB] is op1=2 & op0=9 & opN=5 & opA_p & opA_p2 & opA_p3 & opA_p4 & opA_p5 & opB {
    # Pop step
    opB = opB + 1;
    local stack_addr:3 = segment(0:1, opB);
    opA_p = *:2 stack_addr;

    # Pop step
    opB = opB + 1;
    stack_addr = segment(0:1, opB);
    opA_p2 = *:2 stack_addr;

    # Pop step
    opB = opB + 1;
    stack_addr = segment(0:1, opB);
    opA_p3 = *:2 stack_addr;

    # Pop step
    opB = opB + 1;
    stack_addr = segment(0:1, opB);
    opA_p4 = *:2 stack_addr;

    # Pop step
    opB = opB + 1;
    stack_addr = segment(0:1, opB);
    opA_p5 = *:2 stack_addr;
}

:pop opA_p6,6 "from" [opB] is op1=2 & op0=9 & opN=6 & opA_p & opA_p2 & opA_p3 & opA_p4 & opA_p5 & opA_p6 & opB {
    # Pop step
    opB = opB + 1;
    local stack_addr:3 = segment(0:1, opB);
    opA_p = *:2 stack_addr;

    # Pop step
    opB = opB + 1;
    stack_addr = segment(0:1, opB);
    opA_p2 = *:2 stack_addr;

    # Pop step
    opB = opB + 1;
    stack_addr = segment(0:1, opB);
    opA_p3 = *:2 stack_addr;

    # Pop step
    opB = opB + 1;
    stack_addr = segment(0:1, opB);
    opA_p4 = *:2 stack_addr;

    # Pop step
    opB = opB + 1;
    stack_addr = segment(0:1, opB);
    opA_p5 = *:2 stack_addr;

    # Pop step
    opB = opB + 1;
    stack_addr = segment(0:1, opB);
    opA_p6 = *:2 stack_addr;
}

:pop opA_p7,7 "from" [opB] is op1=2 & op0=9 & opN=7 & opA_p & opA_p2 & opA_p3 & opA_p4 & opA_p5 & opA_p6 & opA_p7 & opB {
    # Pop step
    opB = opB + 1;
    local stack_addr:3 = segment(0:1, opB);
    opA_p = *:2 stack_addr;

    # Pop step
    opB = opB + 1;
    stack_addr = segment(0:1, opB);
    opA_p2 = *:2 stack_addr;

    # Pop step
    opB = opB + 1;
    stack_addr = segment(0:1, opB);
    opA_p3 = *:2 stack_addr;

    # Pop step
    opB = opB + 1;
    stack_addr = segment(0:1, opB);
    opA_p4 = *:2 stack_addr;

    # Pop step
    opB = opB + 1;
    stack_addr = segment(0:1, opB);
    opA_p5 = *:2 stack_addr;

    # Pop step
    opB = opB + 1;
    stack_addr = segment(0:1, opB);
    opA_p6 = *:2 stack_addr;

    # Pop step
    opB = opB + 1;
    stack_addr = segment(0:1, opB);
    opA_p7 = *:2 stack_addr;
}


:push opA "to" [opB] is op1=2 & op0=0xd & opN=1 & opB & opA {
    local stack_addr:3 = segment(0:1, opB);
    *:2 stack_addr = opA;
    opB = opB - 1;
}

macro pushStep(opB, reg_val) {
    local stack_addr:3 = segment(0:1, opB);
    *:2 stack_addr = reg_val;
}

# TODO replace opN, define properly in action section
:push opA,2 "to" [opB] is op0=0xd & op1=2 & opA & opA_u1 & opN=2 & opB {
    pushStep(opB, opA);
    opB = opB - 1;
    pushStep(opB, opA_u1);
    opB = opB - 1;
}

:push opA,3 "to" [opB] is op0=0xd & op1=2 & opA & opA_u1 & opA_u2 & opN=3 & opB {
    pushStep(opB, opA);
    opB = opB - 1;
    pushStep(opB, opA_u1);
    opB = opB - 1;
    pushStep(opB, opA_u2);
    opB = opB - 1;
}

:push opA,4 "to" [opB] is op0=0xd & op1=2 & opA & opA_u1 & opA_u2 & opA_u3 & opN=4 & opB {
    pushStep(opB, opA);
    opB = opB - 1;
    pushStep(opB, opA_u1);
    opB = opB - 1;
    pushStep(opB, opA_u2);
    opB = opB - 1;
    pushStep(opB, opA_u3);
    opB = opB - 1;
}

:push opA,5 "to" [opB] is op0=0xd & op1=2 & opA & opA_u1 & opA_u2 & opA_u3 & opA_u4 & opN=5 & opB {
    pushStep(opB, opA);
    opB = opB - 1;
    pushStep(opB, opA_u1);
    opB = opB - 1;
    pushStep(opB, opA_u2);
    opB = opB - 1;
    pushStep(opB, opA_u3);
    opB = opB - 1;
    pushStep(opB, opA_u4);
    opB = opB - 1;
}

:push opA,6 "to" [opB] is op0=0xd & op1=2 & opA & opA_u1 & opA_u2 & opA_u3 & opA_u4 & opA_u5 & opN=6 & opB {
    pushStep(opB, opA);
    opB = opB - 1;
    pushStep(opB, opA_u1);
    opB = opB - 1;
    pushStep(opB, opA_u2);
    opB = opB - 1;
    pushStep(opB, opA_u3);
    opB = opB - 1;
    pushStep(opB, opA_u4);
    opB = opB - 1;
    pushStep(opB, opA_u5);
    opB = opB - 1;
}

:push opA,7 "to" [opB] is op0=0xd & op1=2 & opA & opA_u1 & opA_u2 & opA_u3 & opA_u4 & opA_u5 & opA_u6 & opN=7 & opB {
    pushStep(opB, opA);
    opB = opB - 1;
    pushStep(opB, opA_u1);
    opB = opB - 1;
    pushStep(opB, opA_u2);
    opB = opB - 1;
    pushStep(opB, opA_u3);
    opB = opB - 1;
    pushStep(opB, opA_u4);
    opB = opB - 1;
    pushStep(opB, opA_u5);
    opB = opB - 1;
    pushStep(opB, opA_u6);
    opB = opB - 1;
}

# u'nSP 2.0 extended instructions
ExtPrefix: is opFull=0xff80 {
    
}

define token extinstr(16)
    extOp0=(12, 15)
    extRa=(8, 11)
    extRb=(0, 3)
    extRx=(9, 11)
    extRy=(0, 2)

    extRx_p1=(9,11)
    extRx_p2=(9,11)
    extRx_p3=(9,11)
    extRx_p4=(9,11)
    extRx_p5=(9,11)
    extRx_p6=(9,11)
    extRx_p7=(9,11)

    extRx_u1=(9,11)
    extRx_u2=(9,11)
    extRx_u3=(9,11)
    extRx_u4=(9,11)
    extRx_u5=(9,11)
    extRx_u6=(9,11)

    extOp1=(4, 7)
    extOp1Ext=(4, 8)

    extOpN=(3, 5)

    extOp2=(6, 8)
    extD=(5, 5)
    extW=(4, 4)
    extAt=(3, 3)

    extIM6=(0, 5)
    extA6=(0, 5)

    extPushSize=(12,14)
    extPushMode=(15,15)
;

attach variables [ extRa extRb ] [ sp r1 r2 r3 r4 bp sr pc r8 r9 r10 r11 r12 r13 r14 r15 ];
attach variables [ extRx extRy ] [ r8 r9 r10 r11 r12 r13 r14 r15 ];

extOpA: extRa is extRa { export extRa; }
extOpB: extRb is extRb { export extRb; }

extOpX: extRx is extRx { export extRx; }
extOpY: extRy is extRy { export extRy; }

# Bizarrely shifted
attach variables [ extRx_p1 ] [ r9 r10 r11 r12 r13 r14 r15 r8];
attach variables [ extRx_p2 ] [ r10 r11 r12 r13 r14 r15 r8 r9 ];
attach variables [ extRx_p3 ] [ r11 r12 r13 r14 r15 r8 r9 r10 ];
attach variables [ extRx_p4 ] [ r12 r13 r14 r15 r8 r9 r10 r11 ];
attach variables [ extRx_p5 ] [ r13 r14 r15 r8 r9 r10 r11 r12 ];
attach variables [ extRx_p6 ] [ r14 r15 r8 r9 r10 r11 r12 r13 ];
attach variables [ extRx_p7 ] [ r15 r8 r9 r10 r11 r12 r13 r14 ];

attach variables [ extRx_u1] [ _ r8 r9 r10 r11 r12 r13 r14 ];
attach variables [ extRx_u2] [ _ _ r8 r9 r10 r11 r12 r13 ];
attach variables [ extRx_u3] [ _ _ _ r8 r9 r10 r11 r12 ];
attach variables [ extRx_u4] [ _ _ _ _ r8 r9 r10 r11 ]; 
attach variables [ extRx_u5] [ _ _ _ _ _ r8 r9 r10 ];
attach variables [ extRx_u6] [ _ _ _ _ _ _ r8 r9 ];

# Ext ALU6

ExtIndirectOp: ""[extOpY] is extOpN=0 & extOpY {
    export *:2 extOpY;
} 
ExtIndirectOp: ""[extOpY--] is extOpN=1 & extOpY {
    local tmp = extOpY;
    extOpY = extOpY - 1;
    export *:2 tmp;
} 
ExtIndirectOp: ""[extOpY++] is extOpN=2 & extOpY {
    local tmp = extOpY;
    extOpY = extOpY + 1;
    export *:2 tmp;
} 
ExtIndirectOp: ""[++extOpY] is extOpN=3 & extOpY {
    extOpY = extOpY + 1;
    export *:2 extOpY;
} 
ExtIndirectOp: "ds":[extOpY] is extOpN=4 & extOpY {
    local addr:3 = segment(ds, extOpY);
    export *:2 addr;
} 
ExtIndirectOp: "ds":[extOpY--] is extOpN=5 & extOpY {
    local addr:3 = segment(ds, extOpY);
    ds = ds - sborrow(extOpY, 1);
    extOpY = extOpY - 1;
    export *:2 addr;
} 
ExtIndirectOp: "ds":[extOpY++] is extOpN=6 & extOpY {
    local addr:3 = segment(ds, extOpY);
    ds = ds + scarry(extOpY, 1);
    extOpY = extOpY + 1;
    export *:2 addr;
} 
ExtIndirectOp: "ds":[++extOpY] is extOpN=7 & extOpY {
    ds = ds + scarry(extOpY, 1);
    extOpY = extOpY + 1;
    local addr:3 = segment(ds, extOpY);
    export *:2 addr;
}
ExtALU6BaseDisplacement: ["bp"+extIM6] is extIM6 {
    # Stack is always located in Bank 0
    local stack_addr:3 = segment(0:1, bp+extIM6);
    local term = *:2 stack_addr;
    export term;
}
ExtALU6Mem: ""[extIM6] is extIM6 { export *:2 extIM6; }

# r8 += r9
# Ext Register
:^extOpA += extOpB is ExtPrefix ; (extOp0=0 & extOp1=0 & extOpA & extOpB) ... {
    local origextOpA:2 = extOpA;
    extOpA = extOpA + extOpB;
    setResultFlags(extOpA);
    setAddFlags(origextOpA, extOpB);
}
# r8 += 1
# Ext IMM16
:^extOpA += imm16 is ExtPrefix ; (extOp0=0 & extOp1=4 & extOpA) ; imm16 {
    local origextOpA:2 = extOpA;
    extOpA = extOpA + imm16;
    setResultFlags(extOpA);
    setAddFlags(origextOpA, imm16);
}
# r8 = r9 + [imm]
# Ext A16
:^extOpA = extOpB + Bank0Mem is ExtPrefix ; (extOp0=0 & extOp1=6 & extOpA & extOpB) ; Bank0Mem {
	extOpA = extOpB + Bank0Mem;
	setResultFlags(extOpA);
	setAddFlags(extOpB, Bank0Mem);
}
# [imm] = r8 + r9
:^Bank0Mem = extOpA + extOpB is ExtPrefix ; (extOp0=0 & extOp1=7 & extOpA & extOpB) ; Bank0Mem {
	Bank0Mem = extOpA + extOpB;
	setResultFlags(Bank0Mem);
	setAddFlags(extOpA, extOpB);
}
# r8 = r8 + [r9]
# r8 = r8 + ds:[r9]
# Ext DS_Indirect 
:^extOpX += ExtIndirectOp is ExtPrefix ; (extOp0=0 & extOp2=2 & extOpX & ExtIndirectOp) {
    local origExtOpX:2 = extOpX;
    extOpX = extOpX + ExtIndirectOp;
    setResultFlags(extOpX);
    setAddFlags(origExtOpX, ExtIndirectOp);
}
# r8 = r8 + imm
# Ext IM6 
:^extOpX += extIM6 is ExtPrefix ; (extOp0=0 & extOp2=6 & extOpX & extIM6) {
    local extOrigOpX:2 = extOpX;
    extOpX = extOpX + extIM6;
    setResultFlags(extOpX);
    setAddFlags(extOrigOpX, extIM6);
}

# r8 = r8 + [bp + 0]
# Ext Base+Disp6
:^extOpX += ExtALU6BaseDisplacement is ExtPrefix ; (extOp0=0 & extOp2=3 & extOpX & ExtALU6BaseDisplacement) {
    local extOrigOpX:2 = extOpX;
    extOpX = extOpX + ExtALU6BaseDisplacement;
    setResultFlags(extOpX);
    setAddFlags(extOrigOpX, ExtALU6BaseDisplacement);
}

# r8 = r8 + [bp + 0]
# Ext A6
:^extOpX += ExtALU6Mem is ExtPrefix ; (extOp0=0 & extOp2=7 & extOpX & ExtALU6Mem) {
    local extOrigOpX:2 = extOpX;
    extOpX = extOpX + ExtALU6Mem;
    setResultFlags(extOpX);
    setAddFlags(extOrigOpX, ExtALU6Mem);
}



# r8 += r9, carry
# Ext Register
:^extOpA += extOpB, "carry" is ExtPrefix ; (extOp0=1 & extOp1=0 & extOpA & extOpB) ... {
    local origextOpA:2 = extOpA;
    extOpA = extOpA + extOpB + zext(C_flag);
    setResultFlags(extOpA);
    setAddCarryFlags(origextOpA, extOpB);
}

# r8 += 1, carry
# Ext IMM16
:^extOpA += imm16, "carry" is ExtPrefix ; (extOp0=1 & extOp1=4 & extOpA) ; imm16 {
    local origextOpA:2 = extOpA;
    extOpA = extOpA + imm16 + zext(C_flag);
    setResultFlags(extOpA);
    setAddCarryFlags(origextOpA, imm16);
}

# r8 = r9 + [imm], carry
# Ext A16
:^extOpA = extOpB + Bank0Mem, "carry" is ExtPrefix ; (extOp0=1 & extOp1=6 & extOpA & extOpB) ; Bank0Mem {
    extOpA = extOpB + Bank0Mem + zext(C_flag);
    setResultFlags(extOpA);
    setAddCarryFlags(extOpB, Bank0Mem);
}

# [imm] = r8 + r9, carry
:^Bank0Mem = extOpA + extOpB, "carry" is ExtPrefix ; (extOp0=1 & extOp1=7 & extOpA & extOpB) ; Bank0Mem {
    Bank0Mem = extOpA + extOpB + zext(C_flag);
    setResultFlags(Bank0Mem);
    setAddCarryFlags(extOpA, extOpB);
}

# r8 = r8 + [r9], carry
# r8 = r8 + ds:[r9], carry
# Ext DS_Indirect 
:^extOpX += ExtIndirectOp, "carry" is ExtPrefix ; (extOp0=1 & extOp2=2 & extOpX & ExtIndirectOp) {
    local origExtOpX:2 = extOpX;
    extOpX = extOpX + ExtIndirectOp + zext(C_flag);
    setResultFlags(extOpX);
    setAddCarryFlags(origExtOpX, ExtIndirectOp);
}

# r8 = r8 + imm, carry
# Ext IM6 
:^extOpX += extIM6, "carry" is ExtPrefix ; (extOp0=1 & extOp2=6 & extOpX & extIM6) {
    local extOrigOpX:2 = extOpX;
    extOpX = extOpX + extIM6 + zext(C_flag);
    setResultFlags(extOpX);
    setAddCarryFlags(extOrigOpX, extIM6);
}

# r8 = r8 + [bp + 0], carry
# Ext Base+Disp6
:^extOpX += ExtALU6BaseDisplacement, "carry" is ExtPrefix ; (extOp0=1 & extOp2=3 & extOpX & ExtALU6BaseDisplacement) {
    local extOrigOpX:2 = extOpX;
    extOpX = extOpX + ExtALU6BaseDisplacement + zext(C_flag);
    setResultFlags(extOpX);
    setAddCarryFlags(extOrigOpX, ExtALU6BaseDisplacement);
}

# r8 = r8 + [0], carry
# Ext A6
:^extOpX += ExtALU6Mem, "carry" is ExtPrefix ; (extOp0=1 & extOp2=7 & extOpX & ExtALU6Mem) {
    local extOrigOpX:2 = extOpX;
    extOpX = extOpX + ExtALU6Mem + zext(C_flag);
    setResultFlags(extOpX);
    setAddCarryFlags(extOrigOpX, ExtALU6Mem);
}



# r8 -= r9
# Ext Register
:^extOpA -= extOpB is ExtPrefix ; (extOp0=2 & extOp1=0 & extOpA & extOpB) ... {
    local origextOpA:2 = extOpA;
    extOpA = extOpA - extOpB;
    setResultFlags(extOpA);
    setSubtractFlags(origextOpA, extOpB);
}

# r8 -= imm16
# Ext IMM16
:^extOpA -= imm16 is ExtPrefix ; (extOp0=2 & extOp1=4 & extOpA) ; imm16 {
    local origextOpA:2 = extOpA;
    extOpA = extOpA - imm16;
    setResultFlags(extOpA);
    setSubtractFlags(origextOpA, imm16);
}

# r8 = r9 - [imm]
# Ext A16
:^extOpA = extOpB - Bank0Mem is ExtPrefix ; (extOp0=2 & extOp1=6 & extOpA & extOpB) ; Bank0Mem {
    extOpA = extOpB - Bank0Mem;
    setResultFlags(extOpA);
    setSubtractFlags(extOpB, Bank0Mem);
}

# [imm] = r8 - r9
:^Bank0Mem = extOpA - extOpB is ExtPrefix ; (extOp0=2 & extOp1=7 & extOpA & extOpB) ; Bank0Mem {
    Bank0Mem = extOpA - extOpB;
    setResultFlags(Bank0Mem);
    setSubtractFlags(extOpA, extOpB);
}

# r8 -= [r9]
# r8 -= ds:[r9]
# Ext DS_Indirect 
:^extOpX -= ExtIndirectOp is ExtPrefix ; (extOp0=2 & extOp2=2 & extOpX & ExtIndirectOp) {
    local origExtOpX:2 = extOpX;
    extOpX = extOpX - ExtIndirectOp;
    setResultFlags(extOpX);
    setSubtractFlags(origExtOpX, ExtIndirectOp);
}

# r8 -= imm6
# Ext IM6 
:^extOpX -= extIM6 is ExtPrefix ; (extOp0=2 & extOp2=6 & extOpX & extIM6) {
    local extOrigOpX:2 = extOpX;
    extOpX = extOpX - extIM6;
    setResultFlags(extOpX);
    setSubtractFlags(extOrigOpX, extIM6);
}

# r8 -= [bp + imm6]
# Ext Base+Disp6
:^extOpX -= ExtALU6BaseDisplacement is ExtPrefix ; (extOp0=2 & extOp2=3 & extOpX & ExtALU6BaseDisplacement) {
    local extOrigOpX:2 = extOpX;
    extOpX = extOpX - ExtALU6BaseDisplacement;
    setResultFlags(extOpX);
    setSubtractFlags(extOrigOpX, ExtALU6BaseDisplacement);
}

# r8 -= [imm6]
# Ext A6
:^extOpX -= ExtALU6Mem is ExtPrefix ; (extOp0=2 & extOp2=7 & extOpX & ExtALU6Mem) {
    local extOrigOpX:2 = extOpX;
    extOpX = extOpX - ExtALU6Mem;
    setResultFlags(extOpX);
    setSubtractFlags(extOrigOpX, ExtALU6Mem);
}



# r8 -= r9, carry
# Ext Register
:^extOpA -= extOpB, "carry" is ExtPrefix ; (extOp0=3 & extOp1=0 & extOpA & extOpB) ... {
    local origextOpA:2 = extOpA;
    extOpA = extOpA - extOpB - zext(!C_flag);
    setResultFlags(extOpA);
    setSubtractCarryFlags(origextOpA, extOpB);
}

# r8 -= imm16, carry
# Ext IMM16
:^extOpA -= imm16, "carry" is ExtPrefix ; (extOp0=3 & extOp1=4 & extOpA) ; imm16 {
    local origextOpA:2 = extOpA;
    extOpA = extOpA - imm16 - zext(!C_flag);
    setResultFlags(extOpA);
    setSubtractCarryFlags(origextOpA, imm16);
}

# r8 = r9 - [imm], carry
# Ext A16
:^extOpA = extOpB - Bank0Mem, "carry" is ExtPrefix ; (extOp0=3 & extOp1=6 & extOpA & extOpB) ; Bank0Mem {
    extOpA = extOpB - Bank0Mem - zext(!C_flag);
    setResultFlags(extOpA);
    setSubtractCarryFlags(extOpB, Bank0Mem);
}

# [imm] = r8 - r9, carry
:^Bank0Mem = extOpA - extOpB, "carry" is ExtPrefix ; (extOp0=3 & extOp1=7 & extOpA & extOpB) ; Bank0Mem {
    Bank0Mem = extOpA - extOpB - zext(!C_flag);
    setResultFlags(Bank0Mem);
    setSubtractCarryFlags(extOpA, extOpB);
}

# r8 -= [r9], carry
# r8 -= ds:[r9], carry
# Ext DS_Indirect 
:^extOpX -= ExtIndirectOp, "carry" is ExtPrefix ; (extOp0=3 & extOp2=2 & extOpX & ExtIndirectOp) {
    local origExtOpX:2 = extOpX;
    extOpX = extOpX - ExtIndirectOp - zext(!C_flag);
    setResultFlags(extOpX);
    setSubtractCarryFlags(origExtOpX, ExtIndirectOp);
}

# r8 -= imm6, carry
# Ext IM6 
:^extOpX -= extIM6, "carry" is ExtPrefix ; (extOp0=3 & extOp2=6 & extOpX & extIM6) {
    local extOrigOpX:2 = extOpX;
    extOpX = extOpX - extIM6 - zext(!C_flag);
    setResultFlags(extOpX);
    setSubtractCarryFlags(extOrigOpX, extIM6);
}

# r8 -= [bp + imm6], carry
# Ext Base+Disp6
:^extOpX -= ExtALU6BaseDisplacement, "carry" is ExtPrefix ; (extOp0=3 & extOp2=3 & extOpX & ExtALU6BaseDisplacement) {
    local extOrigOpX:2 = extOpX;
    extOpX = extOpX - ExtALU6BaseDisplacement - zext(!C_flag);
    setResultFlags(extOpX);
    setSubtractCarryFlags(extOrigOpX, ExtALU6BaseDisplacement);
}

# r8 -= [imm6], carry
# Ext A6
:^extOpX -= ExtALU6Mem, "carry" is ExtPrefix ; (extOp0=3 & extOp2=7 & extOpX & ExtALU6Mem) {
    local extOrigOpX:2 = extOpX;
    extOpX = extOpX - ExtALU6Mem - zext(!C_flag);
    setResultFlags(extOpX);
    setSubtractCarryFlags(extOrigOpX, ExtALU6Mem);
}


# cmp r8, r9
# Ext Register
:cmp extOpA, extOpB is ExtPrefix ; (extOp0=4 & extOp1=0 & extOpA & extOpB) ... {
    local res = extOpA - extOpB;
    setResultFlags(res);
    setSubtractFlags(extOpA, extOpB);
}

# cmp r8, imm16
# Ext IMM16
:cmp extOpA, imm16 is ExtPrefix ; (extOp0=4 & extOp1=4 & extOpA) ; imm16 {
    local res = extOpA - imm16;
    setResultFlags(res);
    setSubtractFlags(extOpA, imm16);
}

# cmp r8, [imm]
# Ext A16
:cmp extOpA, Bank0Mem is ExtPrefix ; (extOp0=4 & extOp1=6 & extOpA) ; Bank0Mem {
    local res = extOpA - Bank0Mem;
    setResultFlags(res);
    setSubtractFlags(extOpA, Bank0Mem);
}

# cmp [imm], r8
:cmp Bank0Mem, extOpA is ExtPrefix ; (extOp0=4 & extOp1=7 & extOpA) ; Bank0Mem {
    local res = Bank0Mem - extOpA;
    setResultFlags(res);
    setSubtractFlags(Bank0Mem, extOpA);
}

# cmp r8, [r9]
# cmp r8, ds:[r9]
# Ext DS_Indirect 
:cmp extOpX, ExtIndirectOp is ExtPrefix ; (extOp0=4 & extOp2=2 & extOpX & ExtIndirectOp) {
    local res = extOpX - ExtIndirectOp;
    setResultFlags(res);
    setSubtractFlags(extOpX, ExtIndirectOp);
}

# cmp r8, imm6
# Ext IM6 
:cmp extOpX, extIM6 is ExtPrefix ; (extOp0=4 & extOp2=6 & extOpX & extIM6) {
    local res = extOpX - extIM6;
    setResultFlags(res);
    setSubtractFlags(extOpX, extIM6);
}

# cmp r8, [bp + imm6]
# Ext Base+Disp6
:cmp extOpX, ExtALU6BaseDisplacement is ExtPrefix ; (extOp0=4 & extOp2=3 & extOpX & ExtALU6BaseDisplacement) {
    local res = extOpX - ExtALU6BaseDisplacement;
    setResultFlags(res);
    setSubtractFlags(extOpX, ExtALU6BaseDisplacement);
}

# cmp r8, [imm6]
# Ext A6
:cmp extOpX, ExtALU6Mem is ExtPrefix ; (extOp0=4 & extOp2=7 & extOpX & ExtALU6Mem) {
    local res = extOpX - ExtALU6Mem;
    setResultFlags(res);
    setSubtractFlags(extOpX, ExtALU6Mem);
}


# r8 = -r9
# Ext Register
:^extOpA = -extOpB is ExtPrefix ; (extOp0=6 & extOp1=0 & extOpA & extOpB) ... {
    extOpA = -extOpB;
    setResultFlags(extOpA);
}

# r8 = -imm16
# Ext IMM16
:^extOpA = -imm16 is ExtPrefix ; (extOp0=6 & extOp1=4 & extOpA) ; imm16 {
    extOpA = -imm16;
    setResultFlags(extOpA);
}

# r8 = -[imm]
# Ext A16
:^extOpA = -Bank0Mem is ExtPrefix ; (extOp0=6 & extOp1=6 & extOpA) ; Bank0Mem {
    extOpA = -Bank0Mem;
    setResultFlags(extOpA);
}

# [imm] = -r8
:^Bank0Mem = -extOpA is ExtPrefix ; (extOp0=6 & extOp1=7 & extOpA) ; Bank0Mem {
    Bank0Mem = -extOpA;
    setResultFlags(Bank0Mem);
}

# r8 = -[r9]
# r8 = -ds:[r9]
# Ext DS_Indirect 
:^extOpX = -ExtIndirectOp is ExtPrefix ; (extOp0=6 & extOp2=2 & extOpX & ExtIndirectOp) {
    extOpX = -ExtIndirectOp;
    setResultFlags(extOpX);
}

# r8 = -imm6
# Ext IM6 
:^extOpX = -extIM6 is ExtPrefix ; (extOp0=6 & extOp2=6 & extOpX & extIM6) {
    extOpX = -extIM6;
    setResultFlags(extOpX);
}

# r8 = -[bp + imm6]
# Ext Base+Disp6
:^extOpX = -ExtALU6BaseDisplacement is ExtPrefix ; (extOp0=6 & extOp2=3 & extOpX & ExtALU6BaseDisplacement) {
    extOpX = -ExtALU6BaseDisplacement;
    setResultFlags(extOpX);
}

# r8 = -[imm6]
# Ext A6
:^extOpX = -ExtALU6Mem is ExtPrefix ; (extOp0=6 & extOp2=7 & extOpX & ExtALU6Mem) {
    extOpX = -ExtALU6Mem;
    setResultFlags(extOpX);
}


# r8 ^= r9
# Ext Register
:^extOpA "^"= extOpB is ExtPrefix ; (extOp0=8 & extOp1=0 & extOpA & extOpB) ... {
    extOpA = extOpA ^ extOpB;
    setResultFlags(extOpA);
}

# r8 ^= imm16
# Ext IMM16
:^extOpA "^"= imm16 is ExtPrefix ; (extOp0=8 & extOp1=4 & extOpA) ; imm16 {
    extOpA = extOpA ^ imm16;
    setResultFlags(extOpA);
}

# r8 = r9 ^ [imm]
# Ext A16
:^extOpA = extOpB "^" Bank0Mem is ExtPrefix ; (extOp0=8 & extOp1=6 & extOpA & extOpB) ; Bank0Mem {
    extOpA = extOpB ^ Bank0Mem;
    setResultFlags(extOpA);
}

# [imm] = r8 ^ r9
:^Bank0Mem = extOpA "^" extOpB is ExtPrefix ; (extOp0=8 & extOp1=7 & extOpA & extOpB) ; Bank0Mem {
    Bank0Mem = extOpA ^ extOpB;
    setResultFlags(Bank0Mem);
}

# r8 ^= [r9]
# r8 ^= ds:[r9]
# Ext DS_Indirect 
:^extOpX "^"= ExtIndirectOp is ExtPrefix ; (extOp0=8 & extOp2=2 & extOpX & ExtIndirectOp) {
    extOpX = extOpX ^ ExtIndirectOp;
    setResultFlags(extOpX);
}

# r8 ^= imm6
# Ext IM6 
:^extOpX "^"= extIM6 is ExtPrefix ; (extOp0=8 & extOp2=6 & extOpX & extIM6) {
    extOpX = extOpX ^ extIM6;
    setResultFlags(extOpX);
}

# r8 ^= [bp + imm6]
# Ext Base+Disp6
:^extOpX "^"= ExtALU6BaseDisplacement is ExtPrefix ; (extOp0=8 & extOp2=3 & extOpX & ExtALU6BaseDisplacement) {
    extOpX = extOpX ^ ExtALU6BaseDisplacement;
    setResultFlags(extOpX);
}

# r8 ^= [imm6]
# Ext A6
:^extOpX "^"= ExtALU6Mem is ExtPrefix ; (extOp0=8 & extOp2=7 & extOpX & ExtALU6Mem) {
    extOpX = extOpX ^ ExtALU6Mem;
    setResultFlags(extOpX);
}


# r8 = [bp+imm6]
# Ext Base+Disp6
:^extOpA = ExtALU6BaseDisplacement is ExtPrefix ; (extOp0=9 & extOp1=0 & extOpA & ExtALU6BaseDisplacement) {
    extOpA = ExtALU6BaseDisplacement;
    setResultFlags(extOpA);
}

# r8 = imm16
# Ext IMM16
:^extOpA = imm16 is ExtPrefix ; (extOp0=9 & extOp1=4 & extOpA) ; imm16 {
    extOpA = imm16;
    setResultFlags(extOpA);
}

# r8 = [imm]
# Ext A16
:^extOpA = Bank0Mem is ExtPrefix ; (extOp0=9 & extOp1=6 & extOpA) ; Bank0Mem {
    extOpA = Bank0Mem;
    setResultFlags(extOpA);
}

# [imm] = r8
:^Bank0Mem = extOpA is ExtPrefix ; (extOp0=9 & extOp1=7 & extOpA) ; Bank0Mem {
    Bank0Mem = extOpA;
    setResultFlags(Bank0Mem);
}

# r8 = [r9]
# r8 = ds:[r9]
# Ext DS_Indirect 
:^extOpX = ExtIndirectOp is ExtPrefix ; (extOp0=9 & extOp2=2 & extOpX & ExtIndirectOp) {
    extOpX = ExtIndirectOp;
    setResultFlags(extOpX);
}

# r8 = imm6
# Ext IM6 
:^extOpX = extIM6 is ExtPrefix ; (extOp0=9 & extOp2=6 & extOpX & extIM6) {
    extOpX = extIM6;
    setResultFlags(extOpX);
}

# r8 = [bp + imm6]
# Ext Base+Disp6
:^extOpX = ExtALU6BaseDisplacement is ExtPrefix ; (extOp0=9 & extOp2=3 & extOpX & ExtALU6BaseDisplacement) {
    extOpX = ExtALU6BaseDisplacement;
    setResultFlags(extOpX);
}

# r8 = [imm6]
# Ext A6
:^extOpX = ExtALU6Mem is ExtPrefix ; (extOp0=9 & extOp2=7 & extOpX & ExtALU6Mem) {
    extOpX = ExtALU6Mem;
    setResultFlags(extOpX);
}


# r8 |= r9
# Ext Register
:^extOpA |= extOpB is ExtPrefix ; (extOp0=0xa & extOp1=0 & extOpA & extOpB) ... {
    extOpA = extOpA | extOpB;
    setResultFlags(extOpA);
}

# r8 |= imm16
# Ext IMM16
:^extOpA |= imm16 is ExtPrefix ; (extOp0=0xa & extOp1=4 & extOpA) ; imm16 {
    extOpA = extOpA | imm16;
    setResultFlags(extOpA);
}

# r8 = r9 | [imm]
# Ext A16
:^extOpA = extOpB | Bank0Mem is ExtPrefix ; (extOp0=0xa & extOp1=6 & extOpA & extOpB) ; Bank0Mem {
    extOpA = extOpB | Bank0Mem;
    setResultFlags(extOpA);
}

# [imm] = r8 | r9
:^Bank0Mem = extOpA | extOpB is ExtPrefix ; (extOp0=0xa & extOp1=7 & extOpA & extOpB) ; Bank0Mem {
    Bank0Mem = extOpA | extOpB;
    setResultFlags(Bank0Mem);
}

# r8 |= [r9]
# r8 |= ds:[r9]
# Ext DS_Indirect 
:^extOpX |= ExtIndirectOp is ExtPrefix ; (extOp0=0xa & extOp2=2 & extOpX & ExtIndirectOp) {
    extOpX = extOpX | ExtIndirectOp;
    setResultFlags(extOpX);
}

# r8 |= imm6
# Ext IM6 
:^extOpX |= extIM6 is ExtPrefix ; (extOp0=0xa & extOp2=6 & extOpX & extIM6) {
    extOpX = extOpX | extIM6;
    setResultFlags(extOpX);
}

# r8 |= [bp + imm6]
# Ext Base+Disp6
:^extOpX |= ExtALU6BaseDisplacement is ExtPrefix ; (extOp0=0xa & extOp2=3 & extOpX & ExtALU6BaseDisplacement) {
    extOpX = extOpX | ExtALU6BaseDisplacement;
    setResultFlags(extOpX);
}

# r8 |= [imm6]
# Ext A6
:^extOpX |= ExtALU6Mem is ExtPrefix ; (extOp0=0xa & extOp2=7 & extOpX & ExtALU6Mem) {
    extOpX = extOpX | ExtALU6Mem;
    setResultFlags(extOpX);
}



# r8 &= r9
# Ext Register
:^extOpA &= extOpB is ExtPrefix ; (extOp0=0xb & extOp1=0 & extOpA & extOpB) ... {
    extOpA = extOpA & extOpB;
    setResultFlags(extOpA);
}

# r8 &= imm16
# Ext IMM16
:^extOpA &= imm16 is ExtPrefix ; (extOp0=0xb & extOp1=4 & extOpA) ; imm16 {
    extOpA = extOpA & imm16;
    setResultFlags(extOpA);
}

# r8 = r9 & [imm]
# Ext A16
:^extOpA = extOpB & Bank0Mem is ExtPrefix ; (extOp0=0xb & extOp1=6 & extOpA & extOpB) ; Bank0Mem {
    extOpA = extOpB & Bank0Mem;
    setResultFlags(extOpA);
}

# [imm] = r8 & r9
:^Bank0Mem = extOpA & extOpB is ExtPrefix ; (extOp0=0xb & extOp1=7 & extOpA & extOpB) ; Bank0Mem {
    Bank0Mem = extOpA & extOpB;
    setResultFlags(Bank0Mem);
}

# r8 &= [r9]
# r8 &= ds:[r9]
# Ext DS_Indirect 
:^extOpX &= ExtIndirectOp is ExtPrefix ; (extOp0=0xb & extOp2=2 & extOpX & ExtIndirectOp) {
    extOpX = extOpX & ExtIndirectOp;
    setResultFlags(extOpX);
}

# r8 &= imm6
# Ext IM6 
:^extOpX &= extIM6 is ExtPrefix ; (extOp0=0xb & extOp2=6 & extOpX & extIM6) {
    extOpX = extOpX & extIM6;
    setResultFlags(extOpX);
}

# r8 &= [bp + imm6]
# Ext Base+Disp6
:^extOpX &= ExtALU6BaseDisplacement is ExtPrefix ; (extOp0=0xb & extOp2=3 & extOpX & ExtALU6BaseDisplacement) {
    extOpX = extOpX & ExtALU6BaseDisplacement;
    setResultFlags(extOpX);
}

# r8 &= [imm6]
# Ext A6
:^extOpX &= ExtALU6Mem is ExtPrefix ; (extOp0=0xb & extOp2=7 & extOpX & ExtALU6Mem) {
    extOpX = extOpX & ExtALU6Mem;
    setResultFlags(extOpX);
}



# test r8, r9
# Ext Register
:test extOpA, extOpB is ExtPrefix ; (extOp0=0xc & extOp1=0 & extOpA & extOpB) ... {
    local res = extOpA & extOpB;
    setResultFlags(res);
}

# test r8, imm16
# Ext IMM16
:test extOpA, imm16 is ExtPrefix ; (extOp0=0xc & extOp1=4 & extOpA) ; imm16 {
    local res = extOpA & imm16;
    setResultFlags(res);
}

# test r8, [imm]
# Ext A16
:test extOpA, Bank0Mem is ExtPrefix ; (extOp0=0xc & extOp1=6 & extOpA) ; Bank0Mem {
    local res = extOpA & Bank0Mem;
    setResultFlags(res);
}

# test [imm], r8
:test Bank0Mem, extOpA is ExtPrefix ; (extOp0=0xc & extOp1=7 & extOpA) ; Bank0Mem {
    local res = Bank0Mem & extOpA;
    setResultFlags(res);
}

# test r8, [r9]
# test r8, ds:[r9]
# Ext DS_Indirect 
:test extOpX, ExtIndirectOp is ExtPrefix ; (extOp0=0xc & extOp2=2 & extOpX & ExtIndirectOp) {
    local res = extOpX & ExtIndirectOp;
    setResultFlags(res);
}

# test r8, imm6
# Ext IM6 
:test extOpX, extIM6 is ExtPrefix ; (extOp0=0xc & extOp2=6 & extOpX & extIM6) {
    local res = extOpX & extIM6;
    setResultFlags(res);
}

# test r8, [bp + imm6]
# Ext Base+Disp6
:test extOpX, ExtALU6BaseDisplacement is ExtPrefix ; (extOp0=0xc & extOp2=3 & extOpX & ExtALU6BaseDisplacement) {
    local res = extOpX & ExtALU6BaseDisplacement;
    setResultFlags(res);
}

# test r8, [imm6]
# Ext A6
:test extOpX, ExtALU6Mem is ExtPrefix ; (extOp0=0xc & extOp2=7 & extOpX & ExtALU6Mem) {
    local res = extOpX & ExtALU6Mem;
    setResultFlags(res);
}


# [bp+imm6] = r8
# Ext Base+Disp6
:^ExtALU6BaseDisplacement = extOpA is ExtPrefix ; (extOp0=0xd & extOp1=0 & extOpA & ExtALU6BaseDisplacement) {
    ExtALU6BaseDisplacement = extOpA;
    # does not update flags
}

# [imm] = r8
# Ext A16
:^Bank0Mem = extOpA is ExtPrefix ; (extOp0=0xd & extOp1=6 & extOpA) ; Bank0Mem {
    Bank0Mem = extOpA;
    # does not update flags
}

# r8 = [imm]
:^Bank0Mem = extOpA "store" is ExtPrefix ; (extOp0=0xd & extOp1=7 & extOpA) ; Bank0Mem {
    Bank0Mem = extOpA;
    # does not update flags
}


# [r9] = r8
# ds:[r9] = r8
# Ext DS_Indirect 
:^ExtIndirectOp = extOpX is ExtPrefix ; (extOp0=0xd & extOp2=2 & extOpX & ExtIndirectOp) {
    ExtIndirectOp = extOpX;
    # does not update flags
}

# [bp+imm6] = r8
# Ext Base+Disp6
:^ExtALU6BaseDisplacement = extOpX is ExtPrefix ; (extOp0=0xd & extOp2=3 & extOpX & ExtALU6BaseDisplacement) {
    ExtALU6BaseDisplacement = extOpX;
    # does not update flags
}

# [imm6] = r8
# Ext A6
:^ExtALU6Mem = extOpX is ExtPrefix ; (extOp0=0xd & extOp2=7 & extOpX & ExtALU6Mem) {
    ExtALU6Mem = extOpX;
    # does not update flags
}

# ext push
:push extOpX "to" [extOpB] is ExtPrefix; (extOp1Ext=2 & extPushMode=1 & extPushSize=1 & extOpB & extOpX) {
    pushStep(extOpB, extOpX);
    extOpB = extOpB - 1;
}

:push extOpX,2 "to" [extOpB] is ExtPrefix; (extOp1Ext=2 & extPushMode=1 & extPushSize=2 & extOpB & extOpX & extRx_u1) {
    pushStep(extOpB, extOpX);
    extOpB = extOpB - 1;
    pushStep(extOpB, extRx_u1);
    extOpB = extOpB - 1;
}

:push extOpX,3 "to" [extOpB] is ExtPrefix; (extOp1Ext=2 & extPushMode=1 & extPushSize=3 & extOpB & extOpX & extRx_u1 & extRx_u2) {
    pushStep(extOpB, extOpX);
    extOpB = extOpB - 1;
    pushStep(extOpB, extRx_u1);
    extOpB = extOpB - 1;
    pushStep(extOpB, extRx_u2);
    extOpB = extOpB - 1;
}

:push extOpX,4 "to" [extOpB] is ExtPrefix; (extOp1Ext=2 & extPushMode=1 & extPushSize=4 & extOpB & extOpX & extRx_u1 & extRx_u2 & extRx_u3) {
    pushStep(extOpB, extOpX);
    extOpB = extOpB - 1;
    pushStep(extOpB, extRx_u1);
    extOpB = extOpB - 1;
    pushStep(extOpB, extRx_u2);
    extOpB = extOpB - 1;
    pushStep(extOpB, extRx_u3);
    extOpB = extOpB - 1;
}

:push extOpX,5 "to" [extOpB] is ExtPrefix; (extOp1Ext=2 & extPushMode=1 & extPushSize=5 & extOpB & extOpX & extRx_u1 & extRx_u2 & extRx_u3 & extRx_u4) {
    pushStep(extOpB, extOpX);
    extOpB = extOpB - 1;
    pushStep(extOpB, extRx_u1);
    extOpB = extOpB - 1;
    pushStep(extOpB, extRx_u2);
    extOpB = extOpB - 1;
    pushStep(extOpB, extRx_u3);
    extOpB = extOpB - 1;
    pushStep(extOpB, extRx_u4);
    extOpB = extOpB - 1;
}

:push extOpX,6 "to" [extOpB] is ExtPrefix; (extOp1Ext=2 & extPushMode=1 & extPushSize=6 & extOpB & extOpX & extRx_u1 & extRx_u2 & extRx_u3 & extRx_u4 & extRx_u5) {
    pushStep(extOpB, extOpX);
    extOpB = extOpB - 1;
    pushStep(extOpB, extRx_u1);
    extOpB = extOpB - 1;
    pushStep(extOpB, extRx_u2);
    extOpB = extOpB - 1;
    pushStep(extOpB, extRx_u3);
    extOpB = extOpB - 1;
    pushStep(extOpB, extRx_u4);
    extOpB = extOpB - 1;
    pushStep(extOpB, extRx_u5);
    extOpB = extOpB - 1;
}

:push extOpX,7 "to" [extOpB] is ExtPrefix; (extOp1Ext=2 & extPushMode=1 & extPushSize=7 & extOpB & extOpX & extRx_u1 & extRx_u2 & extRx_u3 & extRx_u4 & extRx_u5 & extRx_u6) {
    pushStep(extOpB, extOpX);
    extOpB = extOpB - 1;
    pushStep(extOpB, extRx_u1);
    extOpB = extOpB - 1;
    pushStep(extOpB, extRx_u2);
    extOpB = extOpB - 1;
    pushStep(extOpB, extRx_u3);
    extOpB = extOpB - 1;
    pushStep(extOpB, extRx_u4);
    extOpB = extOpB - 1;
    pushStep(extOpB, extRx_u5);
    extOpB = extOpB - 1;
    pushStep(extOpB, extRx_u6);
    extOpB = extOpB - 1;
}

# ext pop

:pop extRx_p1 "from" [extOpB] is ExtPrefix; (extOp1Ext=2 & extPushMode=0 & extPushSize=1 & extOpB & extRx_p1) {
    # Pop step
    extOpB = extOpB + 1;
    local stack_addr:3 = segment(0:1, extOpB);
    extRx_p1 = *:2 stack_addr;
}

:pop extRx_p2,2 "from" [extOpB] is ExtPrefix; (extOp1Ext=2 & extPushMode=0 & extPushSize=2 & extOpB & extRx_p1 & extRx_p2) {
    # Pop step
    extOpB = extOpB + 1;
    local stack_addr:3 = segment(0:1, extOpB);
    extRx_p1 = *:2 stack_addr;
    
    # Pop step
    extOpB = extOpB + 1;
    stack_addr = segment(0:1, extOpB);
    extRx_p2 = *:2 stack_addr;
}

:pop extRx_p3,3 "from" [extOpB] is ExtPrefix; (extOp1Ext=2 & extPushMode=0 & extPushSize=3 & extOpB & extRx_p1 & extRx_p2 & extRx_p3) {
    # Pop step
    extOpB = extOpB + 1;
    local stack_addr:3 = segment(0:1, extOpB);
    extRx_p1 = *:2 stack_addr;
    
    # Pop step
    extOpB = extOpB + 1;
    stack_addr = segment(0:1, extOpB);
    extRx_p2 = *:2 stack_addr;

    # Pop step
    extOpB = extOpB + 1;
    stack_addr = segment(0:1, extOpB);
    extRx_p3 = *:2 stack_addr;
}

:pop extRx_p4,4 "from" [extOpB] is ExtPrefix; (extOp1Ext=2 & extPushMode=0 & extPushSize=4 & extOpB & extRx_p1 & extRx_p2 & extRx_p3 & extRx_p4) {
    # Pop step
    extOpB = extOpB + 1;
    local stack_addr:3 = segment(0:1, extOpB);
    extRx_p1 = *:2 stack_addr;
    
    # Pop step
    extOpB = extOpB + 1;
    stack_addr = segment(0:1, extOpB);
    extRx_p2 = *:2 stack_addr;

    # Pop step
    extOpB = extOpB + 1;
    stack_addr = segment(0:1, extOpB);
    extRx_p3 = *:2 stack_addr;

    # Pop step
    extOpB = extOpB + 1;
    stack_addr = segment(0:1, extOpB);
    extRx_p4 = *:2 stack_addr;
}

:pop extRx_p5,5 "from" [extOpB] is ExtPrefix; (extOp1Ext=2 & extPushMode=0 & extPushSize=5 & extOpB & extRx_p1 & extRx_p2 & extRx_p3 & extRx_p4 & extRx_p5) {
    # Pop step
    extOpB = extOpB + 1;
    local stack_addr:3 = segment(0:1, extOpB);
    extRx_p1 = *:2 stack_addr;
    
    # Pop step
    extOpB = extOpB + 1;
    stack_addr = segment(0:1, extOpB);
    extRx_p2 = *:2 stack_addr;

    # Pop step
    extOpB = extOpB + 1;
    stack_addr = segment(0:1, extOpB);
    extRx_p3 = *:2 stack_addr;

    # Pop step
    extOpB = extOpB + 1;
    stack_addr = segment(0:1, extOpB);
    extRx_p4 = *:2 stack_addr;

    # Pop step
    extOpB = extOpB + 1;
    stack_addr = segment(0:1, extOpB);
    extRx_p5 = *:2 stack_addr;
}

:pop extRx_p6,6 "from" [extOpB] is ExtPrefix; (extOp1Ext=2 & extPushMode=0 & extPushSize=6 & extOpB & extRx_p1 & extRx_p2 & extRx_p3 & extRx_p4 & extRx_p5 & extRx_p6) {
    # Pop step
    extOpB = extOpB + 1;
    local stack_addr:3 = segment(0:1, extOpB);
    extRx_p1 = *:2 stack_addr;
    
    # Pop step
    extOpB = extOpB + 1;
    stack_addr = segment(0:1, extOpB);
    extRx_p2 = *:2 stack_addr;

    # Pop step
    extOpB = extOpB + 1;
    stack_addr = segment(0:1, extOpB);
    extRx_p3 = *:2 stack_addr;

    # Pop step
    extOpB = extOpB + 1;
    stack_addr = segment(0:1, extOpB);
    extRx_p4 = *:2 stack_addr;

    # Pop step
    extOpB = extOpB + 1;
    stack_addr = segment(0:1, extOpB);
    extRx_p5 = *:2 stack_addr;

    # Pop step
    extOpB = extOpB + 1;
    stack_addr = segment(0:1, extOpB);
    extRx_p6 = *:2 stack_addr;
}

:pop extRx_p7,7 "from" [extOpB] is ExtPrefix; (extOp1Ext=2 & extPushMode=0 & extPushSize=7 & extOpB & extRx_p1 & extRx_p2 & extRx_p3 & extRx_p4 & extRx_p5 & extRx_p6 & extRx_p7) {
    # Pop step
    extOpB = extOpB + 1;
    local stack_addr:3 = segment(0:1, extOpB);
    extRx_p1 = *:2 stack_addr;
    
    # Pop step
    extOpB = extOpB + 1;
    stack_addr = segment(0:1, extOpB);
    extRx_p2 = *:2 stack_addr;

    # Pop step
    extOpB = extOpB + 1;
    stack_addr = segment(0:1, extOpB);
    extRx_p3 = *:2 stack_addr;

    # Pop step
    extOpB = extOpB + 1;
    stack_addr = segment(0:1, extOpB);
    extRx_p4 = *:2 stack_addr;

    # Pop step
    extOpB = extOpB + 1;
    stack_addr = segment(0:1, extOpB);
    extRx_p5 = *:2 stack_addr;

    # Pop step
    extOpB = extOpB + 1;
    stack_addr = segment(0:1, extOpB);
    extRx_p6 = *:2 stack_addr;

    # Pop step
    extOpB = extOpB + 1;
    stack_addr = segment(0:1, extOpB);
    extRx_p7 = *:2 stack_addr;
}

